CANHack toolkit
===============

The CANHack toolkit is software that bit-bangs the minimal parts of the CAN protocol to mount various attacks on a CAN bus.
It is designed to demonstrate how easy it is with just software access to a pair of GPIO pins connected to RX and TX of a CAN
transceiver to attack a CAN bus right down at the protocol level, with many attacks that are invisible to a simple bus monitor
operating at the CAN frame level. In essence, any device on CAN that can be compromised (e.g. via a buffer overrun remote
execution vulnerability) can mount these attacks on the bus.

.. warning::
    **USING CANHACK CONNECTED TO A REAL VEHICLE IS AT YOUR OWN RISK!**

    It’s quite common for vehicle ECUs to detect
    conditions like bus-off and treat these as a hardware faults, storing a diagnostic trouble code and then shutting off CAN
    communications. This will look very like bricking your car so it is best to use CANHack on a benchtop system rather than
    the real thing.

The CANHack toolkit consists of two parts:

    - Generic C code that can run on any embedded device
    - A MicroPython wrapper around the C CANHack to make it available as a MicroPython class

CANHack needs to run on a microcontroller with access to a free-running counter/timer and a CAN transceiver
that can be access via a pair of GPIO pins (on-chip CAN controllers can nearly always be by-passed by programming
a pin-mux to allow software control of the CAN controllers’s RX/TX pins).

API Classes
-----------

The CANHack toolkit consists of single MicroPython class.

.. toctree::
   :maxdepth: 4

   classes/canhack


Microcontroller resources
-------------------------

The toolkit uses three GPIO pins, as specified in the table below and the free-running
counter of PWM 7.

    +------------+----------------------+------------------+-----------------------------------------+
    | Pico pin   | Function             | Name             | Description                             |
    +============+======================+==================+=========================================+
    | 29         | GP22                 | CANTX            | TX on the CAN transceiver               |
    +------------+----------------------+------------------+-----------------------------------------+
    | 27         | GP21                 | CANRX            | RX on the CAN transceiver               |
    +------------+----------------------+------------------+-----------------------------------------+
    | 4          | GPIO2                | TRIG             | Debugging / trigger pin                 |
    +------------+----------------------+------------------+-----------------------------------------+

CANHack hardware
----------------

The :ref:`CANHack board` provides a CAN transceiver to be driven :py:class:`CANHack` API. An alternative is
to make a breadboard version of this board. This is very simple: a `blog post <https://kentindell.github.io/2021/02/06/canhack-pico/>`_
describes how to do this.

.. warning::
    The debug pin in the blog post is on Pico pin 15, but this has been moved in the new firmware
    to better co-exist with other hardware boards for the Pico.

Using CANHack on the CANPico board
----------------------------------

The :ref:`CANPico` can also run the CANHack toolkit: it uses the same pins. Although the CAN TX
pin to the transceiver driven by the MCP2518 CAN controller it is possible to instruct
the controller to put its TX output pin into open drain mode. This is done automatically by the :py:class:`CAN`
constructor. To stop the CAN controller from being taken online and driving the pin the
drivers are instructed to leave the controller in configuration mode and not to start:

    >>> rp2.CAN(start=False)

Once the controller has been set up the :py:class:`CANHack` API can then be used as normal.
