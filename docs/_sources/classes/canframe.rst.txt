``CANFrame`` --- CAN frame
============================

.. py:class:: CANFrame(canid, [data=None], [remote=False])

    Represents a CAN frame for transmission or reception.

    :param CANID canid: The CAN ID of the frame
    :param bytes data: The payload of the CAN frame
    :param remote: Set to `True` if the frame is a remote frame.

    :raises ValueError: if the length of the data field is greater than 8 or greater than 0 if `remote` is `True`
    :raises TypeError: if `data` is not of type `bytes` or if `canid` is not an instance :py:class:`CANID`

    A :py:class:`CANFrame` instance is created either directly in order to transmit a frame, or is returned from
    the :py:meth:`recv` call.


Methods
--------


.. py:method:: is_remote()

    :return: `True` if the frame is a remote frame
    :rtype: bool

++++++++++

.. py:method:: get_canid()

    :return: the frame's CAN ID
    :rtype: :py:class:`CANID`

++++++++++

.. py:method:: get_id()
    :noindex:

    :return: the numeric arbitration ID as an integer value of the frame's CAN ID
    :rtype: int

++++++++++

.. py:method:: is_extended()
    :noindex:

    :return: `True` if the CAN frame has an extended 29-bit ID
    :rtype: bool

    This is the equivalent function to the :py:meth:`is_extended` method of :py:class:`CANID`. Note that
    the CAN protocol specifies that an extended ID of 0x100 and a standard ID of 0x100 are not the same
    and are arbitrated differently (the top 11 bits of an extended ID are arbitrated against the 11 bits
    of a standard ID).

++++++++++

.. py:method:: get_data()

    :return: the frame's payload; remote frames return zero bytes
    :rtype: bytes

++++++++++

.. py:method:: set_data([data=None])

    Sets the payload of the CAN frame.

    :raises ValueError: if the length of the data field is greater than 8 or if the frame is a remote frame
    :raises TypeError: if `data` is not of type `bytes`

    This function is provided for efficiency to set the frame's payload without requiring the creation of a new instance
    of :py:class:`CANFrame`.

++++++++++

.. py:method:: get_timestamp()

    :return: the frame's timestamp
    :rtype: int

    The timestamp returns `None` when a frame is created through its constructor. If the frame is returned via :py:meth:`recv`
    then the timestamp is an integer representing the time of start-of-frame when it was received. If a frame is queued for
    transmission then the timestamp is the time of the start-of-frame when it was successfully transmitted.

    The timestamp can also be used to determine if a frame queued for transmission has been sent.

    The current time in the CAN controller is returned by the :py:meth:`get_time` call.

++++++++++

.. py:method:: get_index()

    :return: the frame's ID filter index
    :rtype: int

    The filter index is the key value of the ID filter that matched in the CAN controller's ID filtering system (see :ref:`id_filtering`).
    If the frame was not returned via :py:meth:`recv` then this call returns `None`. The filter index is a fast way to identify the
    received frame.

Examples
--------

In all the examples, the classes are assumed to have been imported and a CAN controller initialized:

    >>> from rp2 import *
    >>> c = CAN()

To send a CAN frame with a payload:

    >>> f = CANFrame(CANID(0x123), data=b'hello')
    >>> c.send_frame(f)
    True

This sends a CAN frame with a standard ID of 0x123 and a 5 byte payload of 68 65 6c 6c 6f.

