
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>CANHack — CANHack toolkit &#8212; Yes We CAN  documentation</title>
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="CANHack toolkit" href="../canhacktop.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="canhack-canhack-toolkit">
<h1><code class="docutils literal notranslate"><span class="pre">CANHack</span></code> — CANHack toolkit<a class="headerlink" href="#canhack-canhack-toolkit" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="CANHack">
<em class="property"><span class="pre">class</span> </em><code class="sig-name descname"><span class="pre">CANHack</span></code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">bit_rate=500</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#CANHack" title="Permalink to this definition">¶</a></dt>
<dd><p>Initializes the CANHack toolkit.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if <cite>bit_rate</cite> is not one of <code class="docutils literal notranslate"><span class="pre">500</span></code>, <code class="docutils literal notranslate"><span class="pre">250</span></code>, or <code class="docutils literal notranslate"><span class="pre">125</span></code></p>
</dd>
</dl>
<p>This class manages low-level protocol attacks on the CAN bus. It is included in
pre-built firmware for MicroPython for the Raspberry Pi Pico and uses fixed
pins on the board to interface to a CAN transceiver.</p>
</dd></dl>

<div class="section" id="methods">
<h2>Methods<a class="headerlink" href="#methods" title="Permalink to this headline">¶</a></h2>
<dl class="py method">
<dt id="set_frame">
<code class="sig-name descname"><span class="pre">set_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[can_id=0x7ff]</span> <span class="pre">[,</span> <span class="pre">remote=False]</span> <span class="pre">[,</span> <span class="pre">extended=False]</span> <span class="pre">[,</span> <span class="pre">data=None]</span> <span class="pre">[,</span> <span class="pre">set_dlc=False]</span> <span class="pre">[,</span> <span class="pre">dlc=0]</span> <span class="pre">[,</span> <span class="pre">second=False]</span> </em><span class="sig-paren">)</span><a class="headerlink" href="#set_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the frame buffer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>can_id</strong> (<em>int</em>) – An 11-bit or 29-bit integer representing the CAN ID of the frame</p></li>
<li><p><strong>remote</strong> (<em>bool</em>) – <cite>True</cite> if the frame is a remote frame</p></li>
<li><p><strong>extended</strong> (<em>bool</em>) – <cite>True</cite> if <cite>can_id</cite> is a 29-bit CAN identifier</p></li>
<li><p><strong>data</strong> (<em>bytes</em>) – The payload of the CAN frame</p></li>
<li><p><strong>set_dlc</strong> (<em>bool</em>) – <cite>True</cite> if the DLC should be set to a specific value</p></li>
<li><p><strong>dlc</strong> (<em>int</em>) – the value of DLC if <cite>set_dlc</cite> is <cite>True</cite></p></li>
<li><p><strong>second</strong> (<em>bool</em>) – <cite>True</cite> if this call is setting the shadow frame in preparation for the Janus Attack</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the <cite>dlc</cite> value is &gt; 15 or if the payload is more than 8 bytes or <cite>remote</cite> is <cite>True</cite> and <cite>data</cite> is set</p>
</dd>
</dl>
<p>This function pre-computes the layout of a CAN frame into a frame buffer inside the toolkit (it will set the shadow frame buffer
is <cite>second</cite> is <cite>True</cite> because the Janus Attack requires two separate CAN frames).</p>
<p>This function must be called prior to mounting an attack: the pre-computed bit pattern in the frame buffer is used to
synchronize the attack on a targeted frame.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="get_frame">
<code class="sig-name descname"><span class="pre">get_frame</span></code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">second=False</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#get_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns details of the frame buffer</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>second</strong> (<em>bool</em>) – <cite>True</cite> if the details of the shadow frame buffer should be returned</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>ValueError</strong> – if the selected frame buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<dl class="simple">
<dt>The method returns an 8-element tuple of:</dt><dd><ul class="simple">
<li><p>A string representing the frame bitstream (including stuff bits) with <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">0</span></code> characters for the bits</p></li>
<li><p>A string representing where the stuff bits are located (with <code class="docutils literal notranslate"><span class="pre">X</span></code> being a stuff bit and <code class="docutils literal notranslate"><span class="pre">-</span></code> being a data bit)</p></li>
<li><p>The integer index of the last arbitration bit in the bitstream</p></li>
<li><p>The integer index of the last DLC bit in the bitstream</p></li>
<li><p>The integer index of the last data bit in the bitstream</p></li>
<li><p>The integer index of the last CRC bit in the bitstream</p></li>
<li><p>The integer index of the last EOF bit in the bitstream</p></li>
<li><p>A 15-bit integer of the CRC of the frame</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt>
<code class="sig-name descname"><span class="pre">send_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[timeout=65535]</span> <span class="pre">[,</span> <span class="pre">second=False]</span> <span class="pre">[,</span> <span class="pre">retries=0]</span></em><span class="sig-paren">)</span></dt>
<dd><p>Send a frame on the CAN bus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for idle before giving up</p></li>
<li><p><strong>second</strong> (<em>bool</em>) – <cite>True</cite> if the frame should come from the shadow frame buffer</p></li>
<li><p><strong>retries</strong> (<em>int</em>) – the number of times to try again to send the frame after loss of arbitration or error</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the selected frame buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>This function sends the specified frame on the CAN bus. It waits for the bus to become idle and then starts
transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then
it tries again, up to a maximum set by <cite>retries</cite>.</p>
<p>This function can mount a tradition spoof attack on the bus where the frame pretends to be from another node.
A problem with this being mounted from a CAN controller is the risk of a ‘doom loop’: if the spoof frame and
the legitimate frame happen to win arbitration at the same time then an error will be raised and arbitration
will re-start. This will continue in a loop until one of the devices has gone error passive or bus-off. This
function avoids this risk by being able to skip re-sending.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="send_janus_frame">
<code class="sig-name descname"><span class="pre">send_janus_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[timeout=65535]</span> <span class="pre">[,</span> <span class="pre">sync_time=0]</span> <span class="pre">[,</span> <span class="pre">split_time=0],</span> <span class="pre">[,</span> <span class="pre">retries=0]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#send_janus_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Send a Janus frame on the CAN bus</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for idle before giving up</p></li>
<li><p><strong>sync_time</strong> (<em>int</em>) – The number of clock ticks to wait to ensure controllers have synced (0 = 1/4 of a CAN bit time)</p></li>
<li><p><strong>split_time</strong> (<em>int</em>) – The number of clock ticks from the start of the bit before the second CAN bit value is set (0 = 5/8th of a CAN bit time)</p></li>
<li><p><strong>retries</strong> (<em>int</em>) – the number of times to try to send the frame after loss of arbitration or error</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if either frame buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>This function sends the specified Janus frame on the CAN bus. It waits for the bus to become idle and then starts
transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then
it tries again, up to a maximum set by <cite>retries</cite>.</p>
<p>A Janus frame is a CAN frame with two different contents, specified by the frame buffer and shadow frame buffer. It must have the same
ID and be the same number of bits long, which means it must have the same number of stuff bits (although they can be in different places).</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="spoof_frame">
<code class="sig-name descname"><span class="pre">spoof_frame</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[timeout=65535]</span> <span class="pre">[,</span> <span class="pre">overwrite=False]</span> <span class="pre">[,</span> <span class="pre">retries=0]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#spoof_frame" title="Permalink to this definition">¶</a></dt>
<dd><p>Target a frame and send a spoof version</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for the targeted frame to appear before giving up</p></li>
<li><p><strong>overwrite</strong> (<em>bool</em>) – Once the targeted frame has been detected, overwrite the remainder with the selected spoof frame</p></li>
<li><p><strong>retries</strong> (<em>int</em>) – the number of times to try to send the frame after loss of arbitration or error</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the frame buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>If <cite>overwrite</cite> is <cite>True</cite> then the spoof frame is written over the top of the targeted frame. If the targeted sender is error passive
then it will not be able to signal an error frame and other controllers will receive the spoofed version of the frame. If <cite>overwrite</cite> is
set to <cite>False</cite> then the spoof frame is entered into arbitration immediately following the end of the targeted frame.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="error_attack">
<code class="sig-name descname"><span class="pre">error_attack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[repeat=2]</span> <span class="pre">[,</span> <span class="pre">timeout=2000000]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#error_attack" title="Permalink to this definition">¶</a></dt>
<dd><p>Repeatedly destroy a targeted frame with errors</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for the targeted frame to appear before giving up</p></li>
<li><p><strong>repeat</strong> (<em>int</em>) – the number of times to repeat the attack</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if the timeout occurred, <cite>False</cite> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>A CAN frame with the targeted frame’s ID must be set using the <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a> before calling this
method. When the ID of the targeted CAN frame has been seen then an error is generated (six dominant bits)
and all CAN controllers go into error handling. The error delimiter is targeted for further repeating of
the attack. With this approach a targeted node can quickly be driven into the error passive or bus-off state.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="double_receive_attack">
<code class="sig-name descname"><span class="pre">double_receive_attack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[repeat=2]</span> <span class="pre">[,</span> <span class="pre">timeout=2000000]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#double_receive_attack" title="Permalink to this definition">¶</a></dt>
<dd><p>Cause a targeted frame to be received twice</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for the targeted frame to appear before giving up</p></li>
<li><p><strong>repeat</strong> (<em>int</em>) – the number of times to repeat the attack</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>A CAN frame with the targeted frame’s ID must be set using the <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a> before calling this
method. When the ID of the targeted CAN frame has been seen then an error is generated at the last bit
of the EOF field, after the receivers have accepted the CAN frame but before the transmitter has marked
it as sent. This causes the transmitter to signal an error and retransmit the frame, leading to it being
received twice.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="freeze_doom_loop_attack">
<code class="sig-name descname"><span class="pre">freeze_doom_loop_attack</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="pre">[repeat=2]</span> <span class="pre">[,</span> <span class="pre">timeout=2000000]</span></em><span class="sig-paren">)</span><a class="headerlink" href="#freeze_doom_loop_attack" title="Permalink to this definition">¶</a></dt>
<dd><p>Freeze the bus after a targeted frame has been successfully transmitted</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>timeout</strong> (<em>int</em>) – The number of bit times to wait for the targeted frame to appear before giving up</p></li>
<li><p><strong>repeat</strong> (<em>int</em>) – the number of times to repeat the attack</p></li>
</ul>
</dd>
<dt class="field-even">Raises</dt>
<dd class="field-even"><p><strong>ValueError</strong> – if the buffer has not been set by a prior call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a></p>
</dd>
</dl>
<p>A CAN frame with the targeted frame’s ID must be set using the <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a> before calling this
method. When the ID of the targeted CAN frame has been seen then an overload frame is generated after the last bit
of the EOF field, after the receivers have accepted the CAN frame and the transmitter has marked
it as sent. This causes the controllers to enter the overload frame recovery mode (like error recovery, except
the error counters are not incremented). At the end of the error delimiter, another overload frame is generated
until the number in the <cite>repeat</cite> parameter is reached.</p>
</dd></dl>

</div>
<div class="section" id="diagnostic-methods">
<h2>Diagnostic methods<a class="headerlink" href="#diagnostic-methods" title="Permalink to this headline">¶</a></h2>
<dl class="py method">
<dt id="set_can_tx">
<code class="sig-name descname"><span class="pre">set_can_tx</span></code><span class="sig-paren">(</span><span class="optional">[</span><em class="sig-param"><span class="pre">recessive=True</span></em><span class="optional">]</span><span class="sig-paren">)</span><a class="headerlink" href="#set_can_tx" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets the CAN TX pin to recessive or dominant</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>recessive</strong> – Set to <cite>True</cite> if the pin should be set recessive</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><cite>True</cite> if CAN RX was recessive, <cite>False</cite> otherwise</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
<p>This is intended for diagnostics to check that the TX and RX pins have been identified correctly on
the hardware.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="square_wave">
<code class="sig-name descname"><span class="pre">square_wave</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#square_wave" title="Permalink to this definition">¶</a></dt>
<dd><p>Drives the CAN TX pin with a square wave with a 50:50 duty cycle and a period of two CAN bit times.</p>
<p>The purpose of this function is for hardware bring-up to check that the CAN TX pin is driven correctly.
It is particularly useful if the hardware is being assembled using breadboard and the wiring needs to
be checked.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="loopback">
<code class="sig-name descname"><span class="pre">loopback</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#loopback" title="Permalink to this definition">¶</a></dt>
<dd><p>It waits for a falling edge on CAN RX and then drives the debug / trigger pin with the value of CAN RX
for 160 bit times.</p>
<p>The purpose of this function is for hardware bring-up to check that the CAN RX pin is connected correctly.
It is particularly useful if the hardware is being assembled using breadboard and the wiring needs to
be checked.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="get_clock">
<code class="sig-name descname"><span class="pre">get_clock</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#get_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current time</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The free-running counter used to measure time</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
<p>The purpose of this function is to check that the free-running counter has been initialized properly and
is counting correctly.</p>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="reset_clock">
<code class="sig-name descname"><span class="pre">reset_clock</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#reset_clock" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the free-running counter to zero</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>The value of the counter prior to resetting it</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<hr class="docutils" />
<dl class="py method">
<dt id="send_raw">
<code class="sig-name descname"><span class="pre">send_raw</span></code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#send_raw" title="Permalink to this definition">¶</a></dt>
<dd><p>Sends the raw bitstream of a CAN frame on the CAN TX pin</p>
<p>The CAN frame to send must have been set with a call to <a class="reference internal" href="#set_frame" title="set_frame"><code class="xref py py-meth docutils literal notranslate"><span class="pre">set_frame()</span></code></a> before calling this method.
This call does not enter into CAN arbitration or participate in the CAN protocol, it merely sends a
sequence of bits to the pin. Consequently the CAN bus must be idle when this function is called.</p>
<p>The primary purpose of this function is to check that the bits are output
with correct timing and that the Pico is running fast enough. This can be checked with a logic
analyzer or CAN bus monitor.</p>
</dd></dl>

</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">Yes We CAN</a></h1>








<h3>Navigation</h3>
<p class="caption"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../boardstop.html">Canis CAN boards</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cantop.html">MicroPython CAN API</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../canhacktop.html">CANHack toolkit</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../canhacktop.html#api-classes">API Classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../canhacktop.html#microcontroller-resources">Microcontroller resources</a></li>
<li class="toctree-l2"><a class="reference internal" href="../canhacktop.html#canhack-hardware">CANHack hardware</a></li>
<li class="toctree-l2"><a class="reference internal" href="../canhacktop.html#using-canhack-on-the-canpico-board">Using CANHack on the CANPico board</a></li>
</ul>
</li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="../canhacktop.html">CANHack toolkit</a><ul>
      <li>Previous: <a href="../canhacktop.html" title="previous chapter">CANHack toolkit</a></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2021, Ken Tindell.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 3.5.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/classes/canhack.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>