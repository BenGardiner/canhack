``CANHack`` --- CANHack toolkit
===============================

.. py:class:: CANHack([bit_rate=500])

    Initializes the CANHack toolkit.

    :raises ValueError: if `bit_rate` is not one of ``500``, ``250``, or ``125``

    This class manages low-level protocol attacks on the CAN bus. It is included in
    pre-built firmware for MicroPython for the Raspberry Pi Pico and uses fixed
    pins on the board to interface to a CAN transceiver.

Methods
-------

.. py:method:: set_frame([can_id=0x7ff] [, remote=False] [, extended=False] [, data=None] [, set_dlc=False] [, dlc=0] [, second=False] )

    Sets the frame buffer

    :param int can_id: An 11-bit or 29-bit integer representing the CAN ID of the frame
    :param bool remote: `True` if the frame is a remote frame
    :param bool extended: `True` if `can_id` is a 29-bit CAN identifier
    :param bytes data: The payload of the CAN frame
    :param bool set_dlc: `True` if the DLC should be set to a specific value
    :param int dlc: the value of DLC if `set_dlc` is `True`
    :param bool second: `True` if this call is setting the shadow frame in preparation for the Janus Attack
    :raises ValueError: if the `dlc` value is > 15 or if the payload is more than 8 bytes or `remote` is `True` and `data` is set

    This function pre-computes the layout of a CAN frame into a frame buffer inside the toolkit (it will set the shadow frame buffer
    is `second` is `True` because the Janus Attack requires two separate CAN frames).

    This function must be called prior to mounting an attack: the pre-computed bit pattern in the frame buffer is used to
    synchronize the attack on a targeted frame.

++++++++++

.. py:method:: get_frame([second=False])

    Returns details of the frame buffer

    :param bool second: `True` if the details of the shadow frame buffer should be returned
    :rtype: tuple
    :raises ValueError: if the selected frame buffer has not been set by a prior call to :py:meth:`set_frame`

    The method returns an 8-element tuple of:
        - A string representing the frame bitstream (including stuff bits) with ``1`` and ``0`` characters for the bits
        - A string representing where the stuff bits are located (with ``X`` being a stuff bit and ``-`` being a data bit)
        - The integer index of the last arbitration bit in the bitstream
        - The integer index of the last DLC bit in the bitstream
        - The integer index of the last data bit in the bitstream
        - The integer index of the last CRC bit in the bitstream
        - The integer index of the last EOF bit in the bitstream
        - A 15-bit integer of the CRC of the frame

++++++++++

.. py:method:: send_frame([timeout=65535] [, second=False] [, retries=0])
    :noindex:

    Send a frame on the CAN bus

    :param int timeout: The number of bit times to wait for idle before giving up
    :param bool second: `True` if the frame should come from the shadow frame buffer
    :param int retries: the number of times to try again to send the frame after loss of arbitration or error
    :raises ValueError: if the selected frame buffer has not been set by a prior call to :py:meth:`set_frame`

    This function sends the specified frame on the CAN bus. It waits for the bus to become idle and then starts
    transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then
    it tries again, up to a maximum set by `retries`.

    This function can mount a tradition spoof attack on the bus where the frame pretends to be from another node.
    A problem with this being mounted from a CAN controller is the risk of a 'doom loop': if the spoof frame and
    the legitimate frame happen to win arbitration at the same time then an error will be raised and arbitration
    will re-start. This will continue in a loop until one of the devices has gone error passive or bus-off. This
    function avoids this risk by being able to skip re-sending.

++++++++++

.. py:method:: send_janus_frame([timeout=65535] [, sync_time=0] [, split_time=0], [, retries=0])

    Send a Janus frame on the CAN bus

    :param int timeout: The number of bit times to wait for idle before giving up
    :param int sync_time: The number of clock ticks to wait to ensure controllers have synced (0 = 1/4 of a CAN bit time)
    :param int split_time: The number of clock ticks from the start of the bit before the second CAN bit value is set (0 = 5/8th of a CAN bit time)
    :param int retries: the number of times to try to send the frame after loss of arbitration or error
    :raises ValueError: if either frame buffer has not been set by a prior call to :py:meth:`set_frame`

    This function sends the specified Janus frame on the CAN bus. It waits for the bus to become idle and then starts
    transmitting, following the CAN protocol for arbitration. If it loses arbitration or detects an error then
    it tries again, up to a maximum set by `retries`.

    A Janus frame is a CAN frame with two different contents, specified by the frame buffer and shadow frame buffer. It must have the same
    ID and be the same number of bits long, which means it must have the same number of stuff bits (although they can be in different places).

++++++++++

.. py:method:: spoof_frame([timeout=65535] [, overwrite=False] [, retries=0])

    Target a frame and send a spoof version

    :param int timeout: The number of bit times to wait for the targeted frame to appear before giving up
    :param bool overwrite: Once the targeted frame has been detected, overwrite the remainder with the selected spoof frame
    :param int retries: the number of times to try to send the frame after loss of arbitration or error
    :raises ValueError: if the frame buffer has not been set by a prior call to :py:meth:`set_frame`

    If `overwrite` is `True` then the spoof frame is written over the top of the targeted frame. If the targeted sender is error passive
    then it will not be able to signal an error frame and other controllers will receive the spoofed version of the frame. If `overwrite` is
    set to `False` then the spoof frame is entered into arbitration immediately following the end of the targeted frame.

++++++++++

.. py:method:: error_attack([repeat=2] [, timeout=2000000])

    Repeatedly destroy a targeted frame with errors

    :param int timeout: The number of bit times to wait for the targeted frame to appear before giving up
    :param int repeat: the number of times to repeat the attack
    :return: `True` if the timeout occurred, `False` otherwise
    :rtype: bool
    :raises ValueError: if the buffer has not been set by a prior call to :py:meth:`set_frame`

    A CAN frame with the targeted frame's ID must be set using the :py:meth:`set_frame` before calling this
    method. When the ID of the targeted CAN frame has been seen then an error is generated (six dominant bits)
    and all CAN controllers go into error handling. The error delimiter is targeted for further repeating of
    the attack. With this approach a targeted node can quickly be driven into the error passive or bus-off state.

++++++++++

.. py:method:: double_receive_attack([repeat=2] [, timeout=2000000])

    Cause a targeted frame to be received twice

    :param int timeout: The number of bit times to wait for the targeted frame to appear before giving up
    :param int repeat: the number of times to repeat the attack
    :raises ValueError: if the buffer has not been set by a prior call to :py:meth:`set_frame`

    A CAN frame with the targeted frame's ID must be set using the :py:meth:`set_frame` before calling this
    method. When the ID of the targeted CAN frame has been seen then an error is generated at the last bit
    of the EOF field, after the receivers have accepted the CAN frame but before the transmitter has marked
    it as sent. This causes the transmitter to signal an error and retransmit the frame, leading to it being
    received twice.


++++++++++

.. py:method:: freeze_doom_loop_attack([repeat=2] [, timeout=2000000])

    Freeze the bus after a targeted frame has been successfully transmitted

    :param int timeout: The number of bit times to wait for the targeted frame to appear before giving up
    :param int repeat: the number of times to repeat the attack
    :raises ValueError: if the buffer has not been set by a prior call to :py:meth:`set_frame`

    A CAN frame with the targeted frame's ID must be set using the :py:meth:`set_frame` before calling this
    method. When the ID of the targeted CAN frame has been seen then an overload frame is generated after the last bit
    of the EOF field, after the receivers have accepted the CAN frame and the transmitter has marked
    it as sent. This causes the controllers to enter the overload frame recovery mode (like error recovery, except
    the error counters are not incremented). At the end of the error delimiter, another overload frame is generated
    until the number in the `repeat` parameter is reached.


Diagnostic methods
------------------

.. py:method:: set_can_tx([recessive=True])

    Sets the CAN TX pin to recessive or dominant

    :param recessive: Set to `True` if the pin should be set recessive
    :return: `True` if CAN RX was recessive, `False` otherwise
    :rtype: bool

    This is intended for diagnostics to check that the TX and RX pins have been identified correctly on
    the hardware.

++++++++++


.. py:method:: square_wave()

    Drives the CAN TX pin with a square wave with a 50:50 duty cycle and a period of two CAN bit times.

    The purpose of this function is for hardware bring-up to check that the CAN TX pin is driven correctly.
    It is particularly useful if the hardware is being assembled using breadboard and the wiring needs to
    be checked.

++++++++++

.. py:method:: loopback()

    It waits for a falling edge on CAN RX and then drives the debug / trigger pin with the value of CAN RX
    for 160 bit times.

    The purpose of this function is for hardware bring-up to check that the CAN RX pin is connected correctly.
    It is particularly useful if the hardware is being assembled using breadboard and the wiring needs to
    be checked.


++++++++++

.. py:method:: get_clock()

    Get the current time

    :return: The free-running counter used to measure time
    :rtype: int

    The purpose of this function is to check that the free-running counter has been initialized properly and
    is counting correctly.

++++++++++

.. py:method:: reset_clock()

    Resets the free-running counter to zero

    :return: The value of the counter prior to resetting it
    :rtype: int

++++++++++

.. py:method:: send_raw()

    Sends the raw bitstream of a CAN frame on the CAN TX pin

    The CAN frame to send must have been set with a call to :py:meth:`set_frame` before calling this method.
    This call does not enter into CAN arbitration or participate in the CAN protocol, it merely sends a
    sequence of bits to the pin. Consequently the CAN bus must be idle when this function is called.

    The primary purpose of this function is to check that the bits are output
    with correct timing and that the Pico is running fast enough. This can be checked with a logic
    analyzer or CAN bus monitor.

