``CAN`` --- CAN controller
==========================

.. py:class:: CAN([, profile=0] [, id_filters=None] [, hard_reset=False] [, start=True])

    Represents CAN controller hardware.

    :param int profile: The profile for the CAN bus bit rate (see :ref:`profiles`).
    :param id_filters: A dictionary mapping integers to :py:class:`CANIDFilter` instances (see :ref:`id_filtering`)
    :param bool hard_reset: Set to True to reset the CAN controller at the lowest level (equivalent to power-on reset)
    :param bool start: Set to False to prevent the CAN controller from joining the CAN bus
    :raises TypeError: if the key/value pairs in `id_filters` are not int/instances of :py:class:`CANIDFilter`
    :raises ValueError: if the `profile` value is out of range
    :raises RuntimeError: if the controller hardware is not connected via SPI

    A value of `None` for `id_filters` sets up the CAN controller to accept all incoming frames.

Methods
-------

.. py:method:: send_frame(frame [, fifo=False])

    Queue a frame for transmission on the CAN bus

    :param CANFrame frame: The CAN frame to send
    :param bool fifo: Whether the queue the frame in the FIFO queue (see :ref:`fifo_transmission`)
    :return: `True` if the frame was queued successfully, `False` otherwise
    :rtype: bool
    :raises TypeError: if frame is not an instance of :py:class:`CANFrame`.

++++++++++

.. py:method:: send_frames(frames [, fifo=False)

    Send a collection of CAN frames on the bus

    :param CANFrame frames: A list of CAN frames to send
    :param bool fifo: Whether the queue the frames in the FIFO queue (see :ref:`fifo_transmission`)
    :return: `None`
    :raises TypeError: if `frames` is not a tuple of :py:class:`CANFrame` instances
    :raises ValueError: if there is insufficient room in the queues

++++++++++

.. py:method:: recv([, limit=128])

    Receive CAN frames

    :param int limit: The maximum number of frames to remove from the FIFO (defaults to the entire FIFO)
    :return: a tuple of :py:class:`CANFrame` instances for the CAN frames received since the last call to `recv`
    :rtype: tuple

    The tuple is ordered by the order of CAN frame reception into the receive FIFO and the frames are removed from
    the FIFO. If no frames have been received then an empty tuple is returned. An element in the tuple is `None`
    if there are one or more missing frames because the FIFO was full at that point.

    This function can be polled regularly to return the frames received.

++++++++++

.. py:method:: recv_pending()

    Number of CAN frames in the receive FIFO

    :return: the number of CAN frames pending in the receive FIFO (including any elements of type `None`)
    :rtype: int

++++++++++

.. py:method:: get_send_space([, fifo=False])

    Number of slots for CAN frames in the transmit priority queue or FIFO

    :return: the space in the transmit FIFO (if `fifo` is `False`) else the space in the transmit priority queue
    :rtype: int

++++++++++

.. py:method:: get_status()

    :return: a tuple of four elements: a bool indicating bus-off state, a bool indicating error passive state
             an int representing the Transmit Error Counter, and an int representing the Receive Error Counter
    :rtype: tuple

++++++++++

.. py:method:: get_time()

    :return: The value of the free-running timer used for timestamping transmitted and received CAN frames
    :rtype: int

    The time is represented by an incrementing integer that wraps around to 0. See :ref:`controller_specifics` for
    details on the controller-specific mapping of this count value to real-time.

.. _profiles:

Profiles
--------

The table below gives the CAN bit rate settings for the valid profiles (in the future more profiles may be added).

+------------+----------------------+------------------+----------------------+
| Profile    | Bit rate (Kbit/sec)  | Sample point (%) | Pre-defined constant |
+============+======================+==================+======================+
| 0          | 500                  | 75               | `BITRATE_500K_75`    |
+------------+----------------------+------------------+----------------------+
| 1          | 250                  | 75               | `BITRATE_250K_75`    |
+------------+----------------------+------------------+----------------------+
| 2          | 125                  | 75               | `BITRATE_125K_75`    |
+------------+----------------------+------------------+----------------------+
| 3          | 1000                 | 75               | `BITRATE_1M_75`      |
+------------+----------------------+------------------+----------------------+
| 4          | 500                  | 50               | `BITRATE_500K_50`    |
+------------+----------------------+------------------+----------------------+
| 5          | 250                  | 50               | `BITRATE_250K_50`    |
+------------+----------------------+------------------+----------------------+
| 6          | 125                  | 50               | `BITRATE_125K_50`    |
+------------+----------------------+------------------+----------------------+
| 7          | 1000                 | 50               | `BITRATE_1M_75`      |
+------------+----------------------+------------------+----------------------+

Examples
--------

In all the examples, the classes are assumed to have been imported with:

    >>> from rp2 import *

To create (and initialize) a CAN controller::

    >>> c = CAN()

This initializes the CAN controller on the board with the default profile (500kbit/sec, 75% sample point)
and sets up the ID filtering to receive all frames.

To use a different bus bit rate:

    >>> c = CAN(profile=CAN.BITRATE_250K_75)

To pick up the received CAN frames::

    >>> frames = c.recv()

To run a simple bus analyzer::

    >>> while True:
    >>>     frames = c.recv()
    >>>     for frame in frames:
    >>>         print(frame)

The bus analyzer prints each it sees (See :py:class:`CANFrame` for details).

To set up CAN ID acceptance filters:

    >>> id_filters = {0: CANIDFilter('1001XXXXXXX'), 1: CANIDFilter('XXXXXXXXXXXXXXXXXXXXXXXXX0000'), 31: CANIDFilter())
    >>> c = CAN(id_filters=id_filters)

The acceptance filters are set to accept all frames into the receive FIFO, but frames with an 11-bit ID where the
top four bits are 0b1001 will have an index tag of 0 (accessed by the frame's :func:`get_index` method), frames
with an extended ID where the bottom four bits are 0 will get an index tag of 1 and all other frames will
get an index tag of 31. These tags can be used to quickly identify a frame for further processing.

To only receive 11-bit standard ID frames:

    >>> id_filters = {0: CANIDFilter('XXXXXXXXXXX'))
    >>> c = CAN(id_filters=id_filters)

