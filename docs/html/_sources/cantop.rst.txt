MicroPython CAN API
===================

The CAN API is a MicroPython API for sending and receiving CAN frames. It is included in
the ``rp2`` module on the Raspberry Pi Pico and is provided in the pre-built firmware in the CANHack repository (in the file ``firmware.uf2``),
specifically targeting the Canis Labs CANPico board (see the documentation on :ref:`hardware` for more details on this board).

API Classes
-----------

The CAN API consists of four classes:

- The ``CAN`` class provides control and status of the CAN controller
- The ``CANFrame`` class encapsulates CAN frames, which are either created in software or by receiving them from the CAN controller hardware
- The ``CANID`` class describes a CAN ID: every CAN frame has a CAN ID, but many frames can have the same ID
- The ``CANIDFilter`` class describes how a CAN controller should identify and accept CAN frames based on their CAN ID

.. toctree::
   :maxdepth: 2

   classes/can
   classes/canframe
   classes/canid
   classes/canidfilter

.. _fifo_transmission:

FIFO transmission
-----------------

The CAN arbitration phase selects the highest priority frame to transmit. A well-designed CAN controller will perform internal
arbitration on the same basis: it will enter into bus arbitration its highest priority frame. The drivers of the
MCP2518 configure it for a priority queue of 32 frames. But when two frames with the same ID are queued then the order that
the hardware chooses to send a frame will typically be arbitrary, and this might not be good enough in some cases. For example,
a block message made up from multiple CAN frames must be transmitted in the correct order. To support this the drivers create
an additional FIFO priority queue. At any point in time the frame at the head of the FIFO queue will be in the
priority queue. Once a FIFO frame is transmitted on the CAN bus, the drivers will copy in the next frame in the FIFO queue, and
so on.

Note that the FIFO queue for the MCP2518 is implemented in software: there is a hardware FIFO queue provided by the controller
but it suffers from `priority inversion <https://kentindell.github.io/2020/06/29/can-priority-inversion/>`_
with respect to the priority queue.

.. _id_filtering:

ID filtering
------------

The CAN protocol engine of a CAN controller receives every frame but in most applications the host software
does not need to see all these frames. Instead, ID filters are used to filter out unwanted frames. The
MCP2518 allows 32 ID filters. The matching filter is included in the :py:class:`CANFrame` instance when the
frame is received. ID filters are matched in order, so filter 0 is matched first, down to 31. If no filters
are specified then a default 'match all frames' filter is defined.

See :py:class:`CANIDFilter` for more information on creating ID acceptance filters.


.. _controller_specifics:

Controller specifics
--------------------

MCP2518
+++++++

The Microchip MCP2518 CAN controller has the following hardware specific behaviors:

    - The number of ID acceptance filters is limited to 32, and key values in the `id_filters` dictionary
      must be in the range 0..31.
    - The number of frames in the transmit priority queue is limited to 32.
    - The controller will automatically attempt to recover from bus-off (which requires the controller to
      see 127 idle periods of 11 recessive bits each).
    - Pending CAN frames will be discarded when entering bus-off.

In addition there are specifics of the MCP2518 driver:

    - The number of frames in the FIFO queue that feeds into the hardware
      priority queue is limited to 32.
    - The free-running timestamp counter is a 32-bit integer counting microseconds.
